
编译：

  1. 进入目录：product/access

  2. make EPN105

     如果执行错误，运行make clean后再执行make EPN105

     编译过程中，如果提示yaffs2 file system support (YAFFS_FS) [N/m/y/?] (NEW) 选N，
     我们不需要这个文件系统，我们用的是squashfs文件系统

  3. 如果之前已经执行过make EPN105，那么后面需要编译是只需要执行make all


如果编译过程中报错，需要手动解决，一般情况下只需要增加几个文件夹：
  rm app/bin -rf
  mkdir app/bin

  mkdir app/epon_oam/bin

  mkdir app/lib


升级：

  1. 串口升级

     进入product/access/release/EPN105目录，将文件EPN105V100R006.bin拷贝到tftp根目录下，并将tftp的IP设置为192.168.2.58

     启动目标板，接好串口和网线，按CTRL + E进入boot模式，密码是EPCM1103，并接着按 4->2 直接升级。


CPU侧的flash厂家：CFEON ，器件名：EN25QH64@SOP8


git tag 用法：

1. 新建标签：   git tag -a v1.x.x -m "some illustrations"
2. 删除标签：   git tag -d v1.x.x 
3. 查看已有的标签： git tag

4. push tag 到服务器： git push origin --tags
5. 下载某个tag的代码：  git checkout -b v1.x.x v1.x.x


修改记录：

1. 修改文件：access/config/EPN105/rule.mk
image: makeapp
	cp -f $(PRODUCTDIR)/release/$(ENV_PRO)/u-boot.bin ./u-boot.bin
	cp -f $(PRODUCTDIR)/release/$(ENV_PRO)/$(CONFIG_RELEASE_VER).bin ./temp_for_app.bin
	./makeapp 101 $(CONFIG_RELEASE_VER) temp_for_app.bin u-boot.bin 0 $(ENV_PRO)
	rm -f u-boot.bin temp_for_app.bin
	mv *.img $(PRODUCTDIR)/release/$(ENV_PRO)
	rm -f makeapp.c makeapp

	if [ -d /opt/tftpboot ]; then chmod 666 $(RELEASE_DIR)/*.bin; cp -f $(RELEASE_DIR)/*.bin /opt/tftpboot; fi
      ---将bin文件拷贝到tftpboot目录，以便boot下载。

2. 修改管理vlan设定：
        re8670_rx_skb 函数需要处理管理vlan的报文。

	if((skb->vlan_tci & VLAN_VID_MASK)!=0)
	{
		skb_push_qtag(skb,skb->vlan_tci & VLAN_VID_MASK,0);
	}
	else
	{
		 //skb_push_qtag(skb,s_ui_management_vlan,0);
		 //skb->vlan_tci = s_ui_management_vlan;
	}


    //修改文件： product/access/kernel/linux-2.6.x/drivers/net/re8686.h
    #if defined(CONFIG_VLAN_8021Q)
    #define CP_VLAN_TAG_USED 0  //修改为0，不需要使用这个宏，需要重新定义管理vlan
    #endif



3. 对于cable来的MME 报文，需要增加rtl_tag
   头文件中定义cable所连接的PHY：
#define CLT_PORT_MAX 1  //如果需要增加cable 口，这里需要定义好
#define CLT0_PORT 5 //cable 0 port,use phy 5
#define CLT1_PORT (-1)// phy==-1 means no use it now  //这里指定cable 口的phy
#define CLT2_PORT (-1)// phy==-1 means no use it now
#define CLT3_PORT (-1)// phy==-1 means no use it now

   增加函数：product/access/kernel/linux-2.6.x/drivers/net/re8686.c
   void skb_push_cputag(struct sk_buff *pSkb, u32 phy)

   修改：product/access/kernel/linux-2.6.x/drivers/net/eth.c
   eth_type_trans 函数中增加判断0x8899


   增加定义：product/access/kernel/linux-2.6.x/include/linux/netdevice.h

  typedef struct __packed {
    u16 rtl_eth_type;    // 0x8899
    u8 protocol;
    u8 reason;
    u16 pritag;
    union{
        u16 txmask;
        struct {
            u8 rsvd;
            u8 rxport;
        };
    };
  }cpu_tag_t;/

   这个定义与master进程一致，主要目的是要知道，一个MME 报文收到时，要明确它是从哪个cable口上来的


4. 开机启动master进程和页面根目录：

在product/access/config/rc中增加定义：

	mkdir -p /etc/snmp

	echo "Preparing web pages..."

	mkdir -p /tmp/www
	if [ -f /www.tar ];then
	echo "Found www.tar"
	tar xf /www.tar -C /tmp/www
	elif [ -f /www.tar.gz ];then
	echo "Found www.tar.gz"
	tar xf /www.tar.gz -C /tmp/www
	fi
 
	
	if [ -x /usr/sbin/master ];then
	master
	fi



5. 在文件系统product/access/config/EPN105/rootfs.tgz中增加mtd8 mtd8ro mtdblock8

   mknod -m 755 mtd8 c 90 16 
   mknod -m 755 mtd8ro c 90 17
   mknod -m 755 mtdblock8 c 31 8


6. kernel分区大小设定：
   在product/access/config/EPN105/rule.mk文件中：

    dd bs=65536 count=18 if=$(RELEASE_DIR)/$(CONFIG_RELEASE_VER).bin of=$(RELEASE_DIR)/linux.bin

    修改成：

    dd bs=65536 count=22 if=$(RELEASE_DIR)/$(CONFIG_RELEASE_VER).bin of=$(RELEASE_DIR)/linux.bin


    这样修改后，通过页面升级后，可以正常重启。

    如果需要修改kernel分区的大小，需要同步修改这里的count，

   现在系统的分区是：
    0x00000000-0x00040000   ---boot      size=0x40000
    0x00040000-0x00050000   ---bootenv   size=0x10000
    0x00050000-0x00060000   ---expcfg    size=0x10000
    0x00060000-0x001c0000   ---kernel1   size=0x160000
    0x001c0000-0x003f0000   ---rootfs1   size=0x230000
    0x003f0000-0x00430000   ---nvram1    size=0x40000
    0x00430000-0x00470000   ---nvram2    size-0x40000
    0x00470000-0x005d0000   ---kernel2   size=0x160000
    0x005d0000-0x00800000   ---rootfs2   size=0x230000

   由以上分区，我们设定kernel的大小为0x160000，所以

   bs*count = 65536*22 = 0x160000

   vtysh命令行中，可以用bootflag 1 / bootflag 0来设置启动分区
   在文件系统中可以是修改/proc/manufactory/bootflag文件来控制启动分区
   在boot下可以修改环境变量bootflag=0 ／ bootflag=1来控制启动分区


7. 几处定义与应用代码冲突，解决办法是增加#ifndef BOARD_EPN105
   见文件：
   rtl9607/app/include/lw_drv_req.h

       #ifndef BOARD_EPN105
       #define vlan_mode     para2_u.uiValue
       #endif

   rtl9607/app/include/lw_drv_pub.h

	#ifndef BOARD_EPN105
	#define LINK_TYPE_ACCESS 0
 	....

8. 应用程序传入kernel的phy并不是真正的phy,而是kernel定义的logic phy：

#define    CPU_PORT_NUMBER     7  //to kernel : 7,and true phy - 6
#define    ETH0_PORT_NUMBER    1  //to kernel : 1,and true phy - 0
#define    ETH1_PORT_NUMBER    3  //to kernel : 3,and true phy - 2
#define    ETH2_PORT_NUMBER    4  //to kernel : 4,and true phy - 3

#define    CLT0_PORT_NUMBER    5  //to kernel : 5,and true phy - 5

------------------------------------------------------------------
inline int toLogicPort(int phy)//phy是由kernel直接传上来的真正的phy,
{
	int portmap[] = {
		ETH0_PORT_NUMBER, // phy 0 
		0, // phy 1
        	ETH1_PORT_NUMBER, // phy 2
        	ETH2_PORT_NUMBER, // phy 3
		0, // phy 4
		CLT0_PORT_NUMBER, // phy 5
		CPU_PORT_NUMBER,  // phy 6 	
	};

	if (phy < sizeof(portmap)/sizeof(portmap[0])){
		return portmap[phy];
	}
	return 0;
}


在kernel的定义：

PORT_TYPE_S g_szPortType[LOGIC_PORT_NO+3] = {
/* 0 */    {INVALID_PORT, INVALID_PORT, 0},
/* 1 */    {TO_USERPORT(1, 0, 1),  TOPHYID(0,0),     PORT_TYPE_DEF(0,TP_COPPER, UD_DOWNLINK, SP_1000)},
/* 2 */    {TO_USERPORT(1, 0, 2),  TOPHYID(0,1),     PORT_TYPE_DEF(0,TP_COPPER, UD_DOWNLINK, SP_1000)},
/* 3 */    {TO_USERPORT(1, 0, 3),  TOPHYID(0,2),     PORT_TYPE_DEF(0,TP_COPPER, UD_DOWNLINK, SP_1000)},
/* 4 */    {TO_USERPORT(1, 0, 4),  TOPHYID(0,3),     PORT_TYPE_DEF(0,TP_COPPER, UD_DOWNLINK, SP_1000)},
/* 5 */    {TO_USERPORT(1, 0, 5),  TOPHYID(0,5),     PORT_TYPE_DEF(0,TP_CABLE, UD_DOWNLINK, SP_1000)},
/* 6 */    {TO_USERPORT(1, 0, 6),  TOPHYID(0,4),     PORT_TYPE_DEF(0,TP_COPPER, UD_DOWNLINK, SP_1000)},
/* rtl9607 CPU port is mac 6 and it's port id is port 6. */
/*LGC_CPU*/{TO_USERPORT(1, 0, 7),  TOPHYID(0,6),     PORT_TYPE_DEF(0, TP_CPU, 0, 0)}
};



9.  在rc脚本中，已经启用了br0，所以在master进程中，可以通过br0获取mac和MME报文也可以通过这个br0

	ifconfig eth0 up
	brctl addbr br0

	vconfig add eth0 1
	brctl addif br0 eth0.1
	ifconfig eth0.1 0.0.0.0
	ifconfig br0 up 192.168.0.100 
	ifconfig br0 mtu 1496


10. rtl9607/app/share/Makefile文件中增加：

    	LIB_SWAPI = libswapi.a

	SW_SRCS += $(shell find ./drv -name \*.c)
	OBJS_SW += $(SW_SRCS:.c=.o)
 
swapi:
	$(AR) -r $(LIB_SWAPI) $(OBJS_SW)



11. 增加 #define Ioctl_GetVlanPvid(_port_number, _pvid)


vlan逻辑：
802.1Q vlan:
	access口（注：只允许tag==pvid==mgmt vlan或者不带tag的报文通过）：
	ingress:untag
	egress :untag

	（对于EPN105平台，任何包 带tag or 不带tag 都可以进入）
	
	trunk口：
	ingress： untag报文会加上tag为端口pvid; tag报文不做处理，tag依然为原tag。
	egress :  tag==pvid时，去掉tag,并转发； 
	          tag!=pvid有两种情况:
                  1.如果该trunk口不在该报文的vlan tag所对应的vlan中，则丢弃。
	          2.如果该trunk口在该报文的vlan tag所对应的vlan中，则不做处理，tag依然为原tag并转发。
	
	hybrid口：与trunk口逻辑基本相同，只是trunk口只有当报文中的tag==pvid时，出口逻辑才为untag； 而hybrid口，可以设一组vlan，只要报文中的tag在这一组vlan中，
			  出口逻辑就是untag。
			  

透传模式：
	透传模式为端口vlan模式，只要两个端口在同一vlan中即可通信，但由于管理口只允许一个vlan即管理vlan通信，所以业务口与管理口的通信必须使进入switch的报文的
	tag==mgmt vlan。

        当我们修改管理vlan时，通过管理口可以直接登录cpu,也通过 携带管理vlan的网卡从 业务口登录cpu
        透传模式下：
		管理口的出口逻辑 untag
		管理口的入口逻辑 没有tag的加上pvid,有tag的直接通过
	

cpu口逻辑：
	cpu口逻辑是自定义的，其pvid固定为1，并且好的做法是只允许mgmt vlan的报文通过。
	ingress： untag报文加上tag为pvid，tag报文不做处理，转发。事实上只要到br0的报文都会加上tag的mgmt vlan。
	egress ： 好的做法是设置访问控制列表（ACL），只转发tag==mgmt vlan的报文以及mme的报文，但目前由于有些报文在经过管理口的时候，并未加上tag，所以在cpu的
			  驱动代码中加上了tag为对应端口的pvid。所以目前的出口逻辑是允许任何报文通过，并不做处理。



9. 由于switch转发给CPU 的包，有的包没有加tag就直接传入内核了，之后内核响应这个包时就没有带tag,所以造成问题，现在修改如下：

   在re8686.c文件中的函数 re8670_rx_skb中，增加一个处理：

   1. 先确定这个包是从哪个 port 转发过来的，获取这个口的pvid
   2. 如果这个包已经带tag,那么将这个tag记录在mac表中，如果这个包是不带tag,那么将pvid记录在mac表中,即：

        Drv_MT_AddEntry(skb->data,PortPhyID2Logic(pRxInfo->opts3.bit.src_port_num),
	    (skb->vlan_tci & VLAN_VID_MASK) ? (skb->vlan_tci & VLAN_VID_MASK) : pvid)

   3. 当内核响应该包时，判断响应包是否带tag，如果不带tag，加上mac中tag,如果带tag直接转发，可参见 re8670_start_xmit 的处理方法。



10. 测试vlan逻辑时，可以考虑把diag工具编译出来，通过tftp或者ftp导入到/tmp目录下，直接运行进行调试
    下面命令可供参考：

    vlan get state   ---vlan功能是否打开？
    vlan get transparent state   ---vlan透传是否打开
    vlan get ingress-filter port ( <PORT_LIST:ports> | all ) state   --查看入口限制是否开启
    vlan get accept-frame-type port ( <PORT_LIST:ports> | all )   --查看入口限制模式：
    vlan get pvid port all  --查看pvid配置

    编译diag工具时，只需要在目录/opt/workspace/rtl9607/product/access/config/EPN105/main.config文件下设置：
    CONFIG_DIAG_DEBUG=y

    编译完成后不要急于烧写版本，因为增加这个工具后，版本变得很大，板子的flash不够用了。
    所以可以先拷贝出来放在tftp服务器的目录下，重新make all后升级版本。
    等板子正常跑起来后，可以通过tftp命令将diag放在/tmp目录下使用



11. 增加宏定义： CONFIG_PON
    在clt502-dev/app目录下的Makefile 文件中增加这个定义，用来控制master代码的pon功能是否开启



12. wifi终端的报文处理：

    与wifi终端通信时，进入驱动的报文携带了tag=1的MME报文,把他剥离掉后传给netif_rx函数

    即 rtl9607/product/access/kernel/linux-2.6.x/drivers/net/re8686.c文件中的 re8670_rx_skb 函数中增加：

    if((pRxInfo->opts3.bit.src_port_num == CLT0_PORT) && //from cable and vlan tag is not 0 and type is mme packet,remove tag
        (skb->vlan_tci & VLAN_VID_MASK)               &&
        (skb->data[12]== 0x88 && skb->data[13] == 0xE1)){
        skb->vlan_tci = 0;
    }



13. PON口的处理：
    
    只需要将设置的所有vlan都加入PON的member中即可，参考clt502-dev/app/master/switch目录下的switch.c代码 对于下面3个定义的使用就知道了：
    #define PON0_PORT_NUMBER    6  //to kernel : 6,and true phy - 4
    #define PON_PHY_LIST          PON0_PORT_NUMBER
    #define PON_IFNAME_LIST       IFNAME_PON0

    这里并不是把4096个vlan都加入PON，而是设置了多少个vlan，就加入多少个到PON口。
    也就是说，当我们设置CLT的通信VLAN为200，那么我们只需要设置业务口或者管理口的PVID为200即可。


14. 准备在下一版本加入一键复位功能，使用LED16/GPIO22


15. 修改支持SSH功能

    在EPN105平台中，使用CONFIG_LEGACY_PTYS，而不再是EPN104平台的CONFIG_UNIX98_PTYS，驱动有所改动

    参考配置文件：rtl9607/product/access/config/EPN105/linux.config
    # CONFIG_UNIX98_PTYS is not set
    CONFIG_LEGACY_PTYS=y
    CONFIG_LEGACY_PTY_COUNT=2   ---最多同时支持两个链接 接入局端


    又因为在clt502-dev/app/dropbear-0.53.1/sshpty.c中使用了openpty函数
    而openpty函数是在工具链中定义的：rtl9607/toolchains/rsdk-1.5.6-5281-EB-2.6.30-0.9.30.3-110915/config/uclibc/libutil/openpty.c文件中，
    但是我们拿到的工具链并没有修改，造成的结果是：编译出来的版本有问题，我们无法通过ssh远程到局端上。

    为了简单起见，直接在clt502-dev/app/dropbear-0.53.1/sshpty.c修改，而不去修改工具链

    > 首先在平台增加/tmp/dev目录，里面mknod ptyp* 和 ttyp*设备，因为额/dev目录是readonly的，我们需要把/dev 目录下的ptyp* 和 ttyp*文件链接到/tmp/dev/目录下
      来实现/dev/下的文件可读可写:

      在启动文件 rtl9607/product/access/config/EPN105/rc 中增加：

      mkdir -p /tmp/dev

      mknod /tmp/dev/ttyp0 c 3 0
      ...
      mknod /tmp/dev/ptyp0 c 2 0
      ...
      mknod /tmp/dev/ptypa c 2 10
      ...

      chmod 777 /tmp/dev/* -R

    > 重新修改文件系统下的/dev路径下的ptyp* 和 ttyp*文件：
      rm ptyp* 
      rm ttyp*

      ln -s ../tmp/dev/ptyp0 ptyp0
      ln -s ../tmp/dev/ptyp1 ptyp1
      ...

      ln -s ../tmp/dev/ttyp0 ttyp0
      ln -s ../tmp/dev/ttyp1 ttyp1
      ...

    > 修改clt502-dev/app/dropbear-0.53.1/sshpty.c的函数：openpty
      

    > 修改客户端退出后，ptyp*仍在使用的问题

   以上修改在clt502-dev/app/dropbear-0.53.1目录下的修改都在宏：BOARD_EPN105 下面。
   
16. 透传模式下，将1-4094的所有vlan加入到除管理口和cpu口的所有其他端口中。
	但vlan 1加入到了cpu口和管理口，而管理vlan加入了所有口，且对应管理口的出口逻辑为untag。
	该修改在switch.c中，函数static int vcfg_vlan_config_get(vlan_apply_t *vp)，行2640处。
	
17. 修改局端逻辑端口与物理端口对应关系，从而修改默认的管理口，但默认管理口依然为eth0，只是修改了其对应的phy。
	该修改在switch.c中，函数inline int toLogicPort(int phy)，以及switch_port.h文件中，行333的端口号的宏定义处。
	所以此时的局端代码中的逻辑端口与内核中真正的物理口的对应关系为：
	
	#define    CPU_PORT_NUMBER     7  //to kernel : 7,and true phy - 6

	#define    ETH0_PORT_NUMBER    3  //to kernel : 3,and true phy - 2
	#define    ETH1_PORT_NUMBER    4  //to kernel : 4,and true phy - 3
	#define    CLT1_PORT_NUMBER    1  //to kernel : 1,and true phy - 0

	#define    CLT0_PORT_NUMBER    5  //to kernel : 5,and true phy - 5
	#define    PON0_PORT_NUMBER    6  //to kernel : 6,and true phy - 4
	
18. 解决系统日志显示问题，在文件系统的etc目录下增加配置文件syslog.conf文件，该文件内容如下：
	*.debug	/tmp/log/messages
	*.info	/dev/console
	#*.1	@:
	
	由于之前在var/log目录下没有记录系统信息的messages文件，所以修改rtl9607/product/access/config/EPN105目录下的rc文件，增加创建messages文件的命令，如下：
	rm /tmp/log -rf
	mkdir /tmp/log/ -p
	touch /tmp/log/messages
	chmod 777 /tmp/log/messages

19. 问题：当设置了管理vlan，且配置了大量vlan时，保存当前配置，重启，会出现设不了管理口pvid的错误。
	原因：这是由于当设置了大量vlan，在我们的代码中也就是当设置的vlan数大于100时，会注册一个定时器，然后在这个定时器的回调函数中对设置的vlan进行处理，
	但是代码中，当还没有跑定时器的回调函数时，就先去设置端口pvid，于是由于还没有pvid对应的vlan，导致设置pvid失败。
	解决办法：
	当设了管理vlan，且配置的vlan数目大于100时，就在注册定时器之前先处理所有端口的pvid对应的vlan；
	所以在文件switch.c中定义函数vcfg_vlan_of_pvid_config_apply，然后在函数vcfg_vlan_config_apply中注册定时器之前调用这个定义的函数。
	
20. 增加第二路eoc:
	问题：由于第二路eoc在上电后不会主动发送管理报文，而需主进程先发送一个组播管理报文，只有当第二路eoc收到这个报文后，才会与cpu通信。
	解决办法：代码中有一个定时器，用于定时向eoc发送管理报文，从而获取eoc状态，所以先定义函数，用于发送组播管理报文，然后在该定时器的回调函数中
	调用该函数。修改处在文件clt_mon.c中，增加函数为static void send_packet_to_eoc()。

21. 问题：dhcp功能异常：
	原因：因为我们的dhcp服务器在vlan100中，所以要想与服务器通信就必须要发出带100tag的报文，而我们的驱动代码中，如果收到的报文没带tag的话，
	默认会将br0发出的报文的tag给剥离掉，而其默认会带上管理vlan的tag，所以会出现上述问题。
	解决办法：
	在驱动中剥离发出报文tag的代码处，增加判断，如果是管理的mme报文则继续处理，使其剥离tag，其他的报文则不做处理，继续保有tag。这样发出的报文就会带上
	管理vlan的tag，所以只要将管理vlan设为dhcp服务器所在的vlan，dhcp服务就可以生效。
	修改处在驱动代码的文件re8686.c中，函数__IRAM_NIC int re8670_start_xmit (struct sk_buff *skb, struct net_device *dev)中。


22. 增加支持不识别的flash：

        目前版本支持的flash有 ：

   	spi_flash_MXIC_MX25L25735E_SIO，id = 0x00c22019

	spi_flash_MXIC_MX25L12845E，id = 0x00c22018

	spi_flash_EON_EN25Q64，id = 0x001c3017          ----EN25QH64@SOP8

	spi_flash_WINBOND_W25Q32BV，id = 0x00ef4016

	spi_flash_WINBOND_W25Q128FV，id = 0x00ef4018

	spi_flash_GD_GD25Q128BFIG，id = 0x00c84018

    修改后，对于不识别的flash默认采用spi_flash_EON_EN25Q64(8M flash) 方式。如果系统依然不能启动，只好再次修改驱动了。

    修改的文件有两个，一个是boot下的驱动，一个是kernel下的驱动，分别如下：
    product/access/boot/preloader-9607/preloader/soc/flash/plr_nor_spi_flash.c
    product/access/kernel/linux-2.6.x/drivers/mtd/chips/luna_nor_spi/plr_nor_spi_flash.c

    修改的方法都是增加了定义：genFlash
    具体修改可以参见genFlash的使用。

23. 修改makeapp.c文件，根据系统分区结构，修改偏移量，现在可以直接使用img文件烧写
    /product/access/tools/makeapp.c

	
24. 问题：当在页面或通过命令禁止允许从终端访问局端时，无效。
	解决办法：在内核的l2switch的驱动的acl的初始化函数 DRV_RET_E Hal_AclRuleInit(void) 中，在调用函数__Hal_CreateRuleForCpuMac()中修改如下；
	本函数时将所有端口的报文都转发到cpu，所以在这里将cab口去掉，若今后增加了新类型的端口或端口有修改，并且不需要改端口的包到br0,可在此处进行修改，如下：
	LgcPortFor(uiLPortId)
    {
        uiPPort = PortLogic2PhyPortId(uiLPortId);
        if(uiPPort != 5 && uiPPort != 0)
        {
            uiPPortMask |= (1U << uiPPort);
        }
    }

25. 板载cab口的流控、速率等为固定，拓展的cab为自适应。在rtk_drv_init.c文件中的switch初始化函数DRV_RET_E Hal_SwitchInit(void)内；



26. 修改boot和系统的菜单密码为 EPCM1103

1. 在product/access/config/EPN105/main.config下增加：

CONFIG_HEXICOM_MENU_PASSWORD="EPCM1103"
CONFIG_HEXICOM_BOOT_PASSWORD="EPCM1103"

2. 在product/access/config/EPN105/config.in下增加：
config CONFIG_HEXICOM_MENU_PASSWORD
	string 'menu password'
	default 'EPCM1103'
config CONFIG_HEXICOM_BOOT_PASSWORD
	string 'boot password'
	default 'EPCM1103'
	
3. 在product/access/boot/preloader-9607/u-boot-9607/include/configs/luna.h中定义：

#define CONFIG_BOOT_PASSWORD CONFIG_HEXICOM_BOOT_PASSWORD // CONFIG_PRODUCT_NAME
#define CONFIG_MENU_PASSWORD CONFIG_HEXICOM_MENU_PASSWORD //CONFIG_PRODUCT_NAME
	

27. boot下的sn修改不需要限制，MAC设置需要认证

 在 product/access/boot/preloader-9607/u-boot-9607/common/cmd_manufacture_set.c中的
 do_manufacture_set 函数中，删除sn设置下的条件设置及MAC需要认证
 
 
 28. 修改驱动中，不擦除第一个block的特性
 
  文件： /product/access/kernel/linux-2.6.x/drivers/mtd/chips/luna_nor_spi/spi_cmd.c
 
  mtd_spi_erase 函数  删除一下几句：
  
    // skip 1st block erase
    #if 0
  	if (instr->addr < (mtd->erasesize)) {
		instr->state = MTD_ERASE_DONE;
        printk("mtd_spi_erase():: MTD_ERASE_DONE\n");
		return 0;
	}
	#endif

 
 


29 . 修改以下代码可以使CPU降到500Mhz
  
    /*********************************

    文件： product/access/boot/preloader-9607/preloader/soc/common/plr_pll_gen1.c
    
    函数： otto_pll_gen1_set

    if(is_25MHz){
        target_sys_pll_ctl = 0;//sys_pll_ctl_oc25;  --改为0 后，CPU的频率降为500M  计算公式是：（ target_sys_pll_ctl + 20 ） ＊ 25
    }else{
        target_sys_pll_ctl = 0;//sys_pll_ctl_oc40;  --改为0 后，CPU的频率降为500M  计算公式是：（ target_sys_pll_ctl + 25 ） ＊ 20
    }
    
    还没有版本继续降低，需要新的BOOT
    
    ---- 由于更新了新的 boot,频率降到了300M，可以查看boot的代码中宏定义： CMU_DIVISOR
    
    该宏在makefile文件中定义： product/access/boot/preloader-9607/preloader/Makefile
    
    -DCMU_DIVISOR=2
    
    # compilation flags
CINCF=-I./include -I./platform/current/cpu -I./platform/current -I../release
CDEBUGF=-g -Wall -Wno-unused-parameter
CDEFF=-DSELFTEST=0 -DDECOMP_ALGO=$(DECOMP_ALGO) -DDATE_TAG="\"$(DATE_TAG)\"" -DTBASE=$(TBASE) -DREVISION="\"$(revision)\"" -DREL_VER="\"$(rel_ver)\"" -DCMU_DIVISOR=2
    
    *********************************/
    
30. 使用最新的cfg和ifm的库，代码已经拷贝到代码中，有以下3个文件夹：

   rtl9607/app/cfg
   rtl9607/app/ifm
   rtl9607/kernel/lwmodule/ifm
   
   如果以后这两个库有更新，也要替换这3个文件夹，使用方法如下：
   
   1. 在rtl9607/product/access 目录下：
      make ifm-modules-clean  
      make ifm-modules         ----这两个命令编译出ifm.ko文件，需要手动复制到config/EPN105目录下
      
      make software-cfg-clean
      make software-cfg
      把生成的.so文件 copy 到 config/xxxx(产品目录）
      
      make software-ifm-clean
      make software-ifm       ----这两个命令编译出libifm.a, libifm.so文件，
      
      make sdk-app-clean
      make sdk-app
      make EPN105
      
   2. 以上的说明已经合入到目标： onu-support， 也就是说，在rtl9607/product/access 目录下 make onu-support后即自动地完成上述过程
      但是要注意，要使make onu-support正常编译，需要先make EPN105通过。
      
   如果以后不要更新这两个库，不需要上面的处理过程，直接make EPN105就可以了

31. 在OLT上，show epon onu-interface默认显示vendorid 为H3C，现在改为HC

   修改：
   
   product/access/app/epon_oam/src/epon_oam_db.c
   
   unsigned char oam_onu_vendor[4] = {'H','C',0x00,0x00};//{'H','3','C',0x00};



+==============================================================================================================+
  标题： 33  增加点灯功能
+==============================================================================================================+
  问题描述： 为了方便追查问题，系统启动后增加点灯的过程

  修改原因：

  修改方法： 修改有两处：
  
     增加点灯代码：  
     >  当系统从flash 起来执行时，立刻点亮 lan0 灯
     >  当系统准备通过 pll 拉起 CPU 和 DDR 的时钟前，刻点亮 lan3 灯，
     >  系统时钟被 pll 拉起来后，再把 lan2 灯点亮
     >  初始化串口完成后，点亮 los 灯
     >  串口上发送第一个字符串后，点亮  link 灯
  
           1. 汇编代码刚起来的时候，将lan0灯点亮：
           
              product/access/boot/preloader-9607/preloader/platform/luna_cli/lplr_entry.S  增加如下代码：
              
              lpreloader_start:
							
							lui	a2,0xbb00
							
							。。。。
							
							sw	v0,0(v1)
							
		   2. 在启动第二阶段时，将 lan0 灯熄灭，等到pll将CPU 和 DDR 等的时钟拉起来后，将 lan1 灯点亮：
		   
			  product/access/boot/preloader-9607/preloader/platform/luna_cli/plr_plat_init2.c
			  
			  platform_init_phase_2 函数中 ：
			  
			      plr_led_set(58,1);//dislight lan0  --熄灭 LAN0 灯
				  pll_setup();
				  plr_led_set(60,0);//light lan1  --点亮 LAN1 灯
				  
	 
		      
  修改影响： 无
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.1.R9607
  
  修改时间及作者邮箱： 2015-01-15 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+


+==============================================================================================================+
  标题： 34  修改DDR 启动时prek的方式改成TAK方式(自动检测DDR类型) 
+==============================================================================================================+
  问题描述： 合入rtk的代码，自动识别DDR的类型

  修改原因：

  修改方法： 
			在 product/access/config/EPN105/soc.tcl 文件中增加定义：
			
            add_model dram_gen2 TAK_DDR3_GENERIC_300MHZ
			add_model dram_gen2 TAK_DDR2_GENERIC_300MHZ
				  
  修改影响： 需要测试性能，命令行，页面，MIB等所有涉及内存操作的功能
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.2.R9607
  
  修改时间及作者邮箱： 2015-01-20 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+


+==============================================================================================================+
  标题： 35 针对板子上电不启动，采用启动watchdog的方法来规避问题
+==============================================================================================================+
  问题描述： 在生产中，发现有的板子上电不启动

  修改原因： 目前问题根源没有找到，采用启动watchdog的方法，来规避这个问题。如果后面问题查清楚了，可以把这部分代码删除

  修改方法： 
			在 product/access/boot/preloader-9607/preloader/platform/luna_cli/plr_pll.c 文件中 的 void pll_setup(void) 函数 内： 
			
			REG32(WDTCNTRR_A) = (1ul<<31);// Clear watchdog counters  --- 修改增加的代码
			REG32(WDTINTRR_A) = (PH1_IP) | (PH2_IP); /* Clear interrupt(s) */ --- 修改增加的代码
			REG32(WDTCTRLR_A) = (1ul<<31) | (1ul<<29) | (0x1 << 22) | (0x1 << 15);/* Enable */  --- 修改增加的代码

			/* Enable LX jitter tolerance. */
			REG32(0xB8001004) = REG32(0xB8001004) | 0x80000000;  --- 原来就有的代码

			REG32(WDTCTRLR_A) = 0;/* Disable */   --- 修改增加的代码
			
			如果后面查清楚问题，可以将上面 修改增加的代码 删除
				  
  修改影响： 需要测试性能，命令行，页面，MIB等所有涉及内存操作的功能
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.3.R9607
  
  修改时间及作者邮箱： 2015-01-21 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+


+==============================================================================================================+
  标题： 36 关于 diag 工具的问题
+==============================================================================================================+
  问题描述： 开发中，经常需要独立的调试 switch ,可以用diag工具

  修改原因： 在 乐佩原来的版本中，系统集成了 diag 功能， 在 kernel 中有相关的文件： product/access/app/diag_rtk/src/diag_***.c
           但是当我们改成双备份的功能时，如果将diag包含到rootfs里面去，那么不能编译出版本来，因为版本太大了。
           
           所以我现在将 diag 进程单独编译出来，放在目录 /opt/workspace/rtl9607/tools/diag
           如果你需要使用 diag 来调试，需要将diag通过tftp 或者 ftp的方式 导入到 目标板的 /tmp 目录下面， 加上权限后 可直接运行
           
           当然，如果你觉得 这个编译的版本太老了，需要自己再编译一个，也是可以的，下面会介绍具体的编译方法

  修改方法： 
  
		   使用现有的 diag 工具：
		   
		     用 tftp 工具 将 diag 导入目标版的 /tmp 目录
		   
		     * 将 diag 拷贝到我们的 tftp 服务器的 目录： /opt/tftpboot
		     * 启动目标版，并 在 config terminal 节点下 : debug -> 输入密码 -> vtysh exit -> 进入系统的根目录
		     * cd /tmp; tftp -l diag -g 192.168.0.158;chmod +x diag;./diag;  --- 192.168.0.158 是我的 tftp 服务器，使用时 需要改成你的 tftp 服务器地址
		     * 进入后 提示符是这样的： RTK.0>
		     * 在 RTK.0> 里面，你可以使用 Tab 或者 Shift ? 按键来查看支持哪些命令，你也可以 看看 product/access/app/diag_rtk/src 目录下有 有哪些 diag_***.c 的文件，每一个 文件代码一系列命令
		     
		     
		     
		   编译 diag 工具：
		   
		   在 product/access/config/EPN105/main.config 我文件里面修改：
		   
		   
		   将：
		     
		     # CONFIG_DIAG_DEBUG is not set
		   
		   删除，并修改为:
		   
		     CONFIG_DIAG_DEBUG=y
		     
		   
		   然后在 product/access/ 下面 make EPN105
		   
		   整个编译过程会出错，但是不用管他，只要将 product/access/app/diag_rtk/bin/diag 文件拷贝出来，因为这就是我们需要的 diag 
		   
		   然后将 product/access/rootfs 目录删除，并 将 product/access/config/EPN105/main.config 恢复成原样，也就是说，CONFIG_DIAG_DEBUG 要设置成这样：  # CONFIG_DIAG_DEBUG is not set
		   
		   接着再 make EPN105
		     
  修改影响： 无
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 无
  
  修改时间及作者邮箱： 2015-01-23 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+

+==============================================================================================================+
  标题： 37 组播不转发的问题
+==============================================================================================================+
  问题描述： 测试中发现，业务口的组播流无法转发

  修改原因： 我们使用的版本，默认启用了 igmpsnooping 功能，但是实际上我们不需要这个功能
           因为这个功能的目的是 所有端口的 组播流全部导入 CPU ，再由CPU 决定是否转发到 特定的端口
           
           我们的需求是，组播该转发哪个口就转发，不需要 CPU 介入管理
           

  修改方法： 
			需要修改两个地方：
			 
			* 将igmp 的模式 设置为 CTC 模式，而不是 igmpsnooping 模式
			* 设置组播流转发，而不是导入 CPU
			
			注意： 这个修改是在 eponoamd 进程中进行的，也就是说，如果那天 eponoamd 进程不需要了，我们需要做一个移植操作，将设置 igmp 这部分代码 移植到可以执行的地方，比如 master 进程
			
			修改文件是：
			
			product/access/app/epon_oam/multicast/src/mc_control.c
			
			* 函数 ： OPL_STATUS mcControlBlockInit()

			/* set default values */

			//mcControlBlock.mcRecvEn = OPL_ENABLE;
			//mcControlBlock.mcMode = MC_MODE_SNOOPING;  --  原来的设置

			mcControlBlock.mcRecvEn = OPL_DISABLE;// modify by luoruncai 2015-01-23
			mcControlBlock.mcMode = MC_MODE_CTC;  // modify by luoruncai 2015-01-23  -- 默认值修改为 CTC
			
			* 函数 ： INT32 DRV_SwitchMcInit(void)
			
			增加了宏 ： 
			#if defined(CONFIG_PRODUCT_EPN105)
			-- 这里是修改后的代码，我们需要所有端口转发，所以设置为 PASS_TYPE_ALLPORTS
			#else
			-- 这里是修改前的代码，使用 igmpsnooping ， 所有igmp 流全部导入 CPU ，所以设置为 PASS_TYPE_CPU_ONLY
			#endif
			
			
  修改影响： 需要测试性组播流是否通
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.4.R9607
  
  修改时间及作者邮箱： 2015-01-23 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+

+==============================================================================================================+
  标题： 38 wifi 终端无法读取配置并频繁离线
+==============================================================================================================+
  问题描述： 当wifi的业务口设置为路由模式而且vlan不为1后，wifi无法读取到端口配置，频繁离线，无法管理问题。

  修改原因： 由于wifi发送广播报文时带了业务vlan，导致cable也有该vlan，cpu 的vlan存储表把cable对应的vlan存储起来，
             并带上该vlan回复wifi报文，导致无法正常通信。
  
  修改方法： 
			在 product\access\kernel\linux-2.6.x\drivers\net\re8686.c 文件中 的 re8670_start_xmit 函数内增加，使发送的MME报文不包含tag： 
			 #ifdef CONFIG_EOC_EXTEND
        /* MME packet, has vlan tag or not. wifi slave should be set mme_untagged = 1.*/      
        if (mme_untagged
        && ((0x81 == skb->data[12]) && (0x00 == skb->data[13]))
        && ((0x88 == skb->data[16]) && (0xE1 == skb->data[17]))
        )
        {            
            memmove(skb->data + 12, skb->data + 16, (skb->len) - 16);
        }
        #endif 
		   在 product\access\kernel\linux-2.6.x\drivers\lwdrv\hal\switch\realtek\rtl9607\rtk_drv_vlan.c 增加接口函数获取mme_untagged的值： 
				#ifdef CONFIG_EOC_EXTEND
				/* Cable should be send mme untag packet to wifi slave,otherwise can not manage wifi.Add by Alan Lee,at 2015-03-20 */
				void Hal_SetMMEUntagged(UINT32 untagged)
				{
					mme_untagged = untagged;
					//printk("set mme untagged=%d\n", mme_untagged);
				}				
				#endif
				  
  修改影响： 需要测试wifi业务
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.5.R9607
  
  修改时间及作者邮箱： 2015-03-20 lizhihui@hexicomtech.com                                                                                            
+==============================================================================================================+



+==============================================================================================================+
  标题： 39 光机的串口无法使用
+==============================================================================================================+
  问题描述： 光机的串口无法使用，驱动波特率不支持

  修改原因： 
  
  修改方法： 
	    product\access\kernel\linux-2.6.x\drivers\serial\serial_core.c 文件中 的 int uart_register_driver(struct uart_driver *drv) 函数内，
	    
	    修改结构体：tty_std_termios; -- 参数为115200
	    修改c_cflag  ：normal->init_termios.c_cflag = B115200/*B9600*/ | CS8 | CREAD | HUPCL | CLOCAL;
	    修改c_ispeed ：normal->init_termios.c_ispeed ... = 115200
	
  修改影响： 需要测试串口1
  
  使用范围： 无
                                                                                                               
  修改文件及代码说明： 版本号变更为 V1.0.6.R9607
  
  修改时间及作者邮箱： 2015-04-01 luoruncai@hexicomtech.com                                                                                            
+==============================================================================================================+











