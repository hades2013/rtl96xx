/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "modEoCCBATDevInfoGroup.h"


#include "nscrtv.h"

#ifndef DBGID
#define DBGID  "modeoccnutable"
#endif 

extern oid      version_id[];
extern int      version_id_len;


/** Initializes the modEoCCBATDevInfoGroup module */
void
init_modEoCCBATDevInfoGroup(void)
{
    static oid      modEoCCBATAdminLogicalID_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 1 };
    static oid      modEoCCBATAdminTechProject_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 2 };
    static oid      modEoCCBATAdminManufactoryInfo_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 3 };
    static oid      modEoCCBATAdminModelNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 4 };
    static oid      modEoCCBATAdminSerialNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 5 };
    static oid      modEoCCBATAdminSoftwareVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 6 };
    static oid      modEoCCBATAdminHardwareVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 7 };
    static oid      modEoCCBATAdminVendorSpecialInfo_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 1, 8 };

    DEBUGMSGTL(("modEoCCBATDevInfoGroup", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminLogicalID",
                             handle_modEoCCBATAdminLogicalID,
                             modEoCCBATAdminLogicalID_oid,
                             OID_LENGTH(modEoCCBATAdminLogicalID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminTechProject",
                             handle_modEoCCBATAdminTechProject,
                             modEoCCBATAdminTechProject_oid,
                             OID_LENGTH(modEoCCBATAdminTechProject_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminManufactoryInfo",
                             handle_modEoCCBATAdminManufactoryInfo,
                             modEoCCBATAdminManufactoryInfo_oid,
                             OID_LENGTH
                             (modEoCCBATAdminManufactoryInfo_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminModelNumber",
                             handle_modEoCCBATAdminModelNumber,
                             modEoCCBATAdminModelNumber_oid,
                             OID_LENGTH(modEoCCBATAdminModelNumber_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminSerialNumber",
                             handle_modEoCCBATAdminSerialNumber,
                             modEoCCBATAdminSerialNumber_oid,
                             OID_LENGTH(modEoCCBATAdminSerialNumber_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminSoftwareVersion",
                             handle_modEoCCBATAdminSoftwareVersion,
                             modEoCCBATAdminSoftwareVersion_oid,
                             OID_LENGTH
                             (modEoCCBATAdminSoftwareVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminHardwareVersion",
                             handle_modEoCCBATAdminHardwareVersion,
                             modEoCCBATAdminHardwareVersion_oid,
                             OID_LENGTH
                             (modEoCCBATAdminHardwareVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminVendorSpecialInfo",
                             handle_modEoCCBATAdminVendorSpecialInfo,
                             modEoCCBATAdminVendorSpecialInfo_oid,
                             OID_LENGTH
                             (modEoCCBATAdminVendorSpecialInfo_oid),
                             HANDLER_CAN_RONLY));
}

int
handle_modEoCCBATAdminLogicalID(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)version_id
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 version_id_len/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
 
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminLogicalID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminTechProject(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
	static long value = 0;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = NSCRTV_HPAV;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminTechProject\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminManufactoryInfo(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
	static char vendor_info[] = "Eoc Master";
	/*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */
	
    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)vendor_info
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 strlen(vendor_info)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminManufactoryInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminModelNumber(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
	static char model[] = "CLT101";
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)model
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 strlen(model)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminModelNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminSerialNumber(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
	static char sn[] = "SN00001";
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)sn
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 strlen(sn)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminSerialNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminSoftwareVersion(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
	int ret;
	static sys_info_t info;

	ret = ipc_get_sys_info(&info);

	HC_IPC_ASSERT(ret);
	

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)info.sw_version
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 strlen(info.sw_version)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminSoftwareVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminHardwareVersion(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
	static char hw[] = "REV.A";
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)hw
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 strlen(hw)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminHardwareVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminVendorSpecialInfo(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
	static char spec[] = "";
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)spec
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 0/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminVendorSpecialInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
