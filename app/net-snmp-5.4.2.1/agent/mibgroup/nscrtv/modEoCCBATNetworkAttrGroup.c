/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "modEoCCBATNetworkAttrGroup.h"

#include "nscrtv.h"

#ifndef DBGID
#define DBGID  "modeocnetwork"
#endif 



LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, modEoCCBATNetworkAttrGroup_commit, NULL)


static sys_network_t info;



static oid	modEoCCBATNetworkAttrGroup_oid[] = {1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2};



void init_modEoCCBATNetworkAttrGroup(void)
{
    netsnmp_handler_registration *reginfo;

    /*
     * register ourselves with the agent as a group of scalars...
     */
		
	DEBUGMSGTL((DBGID, "Initializing\n"));

    reginfo = netsnmp_create_handler_registration("modEoCCBATNetworkAttrGroup", modEoCCBATNetworkAttrGroup_handler,
		    modEoCCBATNetworkAttrGroup_oid, OID_LENGTH(modEoCCBATNetworkAttrGroup_oid), HANDLER_CAN_RWRITE);
	
    netsnmp_register_scalar_group(reginfo, MODEOCCBATADMINMACADDRESS, MODEOCCBATADMINIPGATEWAY);


    netsnmp_inject_handler( reginfo,
		    netsnmp_get_cache_handler(  HC_CACHE_TIMEOUT,
			   		modEoCCBATNetworkAttrGroup_load, modEoCCBATNetworkAttrGroup_free,
					modEoCCBATNetworkAttrGroup_oid, OID_LENGTH(modEoCCBATNetworkAttrGroup_oid)));

}

#if 0

/** Initializes the modEoCCBATNetworkAttrGroup module */
void
init_modEoCCBATNetworkAttrGroup(void)
{
    static oid      modEoCCBATAdminMACAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2, 1 };
    static oid      modEoCCBATAdminIPMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2, 2 };
    static oid      modEoCCBATAdminIPAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2, 3 };
    static oid      modEoCCBATAdminIPMask_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2, 4 };
    static oid      modEoCCBATAdminIPGateway_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 2, 4, 1, 2, 5 };

    DEBUGMSGTL(("modEoCCBATNetworkAttrGroup", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminMACAddress",
                             handle_modEoCCBATAdminMACAddress,
                             modEoCCBATAdminMACAddress_oid,
                             OID_LENGTH(modEoCCBATAdminMACAddress_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminIPMode",
                             handle_modEoCCBATAdminIPMode,
                             modEoCCBATAdminIPMode_oid,
                             OID_LENGTH(modEoCCBATAdminIPMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminIPAddress",
                             handle_modEoCCBATAdminIPAddress,
                             modEoCCBATAdminIPAddress_oid,
                             OID_LENGTH(modEoCCBATAdminIPAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminIPMask",
                             handle_modEoCCBATAdminIPMask,
                             modEoCCBATAdminIPMask_oid,
                             OID_LENGTH(modEoCCBATAdminIPMask_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("modEoCCBATAdminIPGateway",
                             handle_modEoCCBATAdminIPGateway,
                             modEoCCBATAdminIPGateway_oid,
                             OID_LENGTH(modEoCCBATAdminIPGateway_oid),
                             HANDLER_CAN_RWRITE));
}
#endif 

int
handle_modEoCCBATAdminMACAddress(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)info->mac.octet
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 HC_MAC_ADDRESS_SIZE/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminMACAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminIPMode(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;
	static long value = 0;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = (info.ip_proto == IP_PROTO_STATIC) ? 0 : 1;		
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 0, 1);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		info.ip_proto = (vb_int(requests->requestvb)) ? IP_PROTO_DYNAMIC : IP_PROTO_STATIC;
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminIPMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminIPAddress(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    int             ret;
	struct in_addr ip;	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                 (u_char *)&info.netif.ip.s_addr
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 HC_IP_ADDRESS_SIZE/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		ip.s_addr = vb_int(requests->requestvb);
		if (!valid_ip(ip)){
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;			
		}			
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		info.netif.ip.s_addr = vb_int(requests->requestvb);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminIPAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminIPMask(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;
	struct in_addr ip;		
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                 (u_char *)&info.netif.subnet.s_addr
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 HC_IP_ADDRESS_SIZE/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		ip.s_addr = vb_int(requests->requestvb);
		if (!valid_subnet_mask(ip, ip)){
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;			
		}			
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			info.netif.subnet.s_addr = vb_int(requests->requestvb);    
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminIPMask\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_modEoCCBATAdminIPGateway(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    int             ret;
	struct in_addr ip;	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:		
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                 (u_char *)&info.netif.gateway.s_addr
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 HC_IP_ADDRESS_SIZE/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		ip.s_addr = vb_int(requests->requestvb);
		if (!valid_ip(ip)){
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;			
		}			
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		info.netif.gateway.s_addr = vb_int(requests->requestvb);	

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
			local_commit();

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_modEoCCBATAdminIPGateway\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int modEoCCBATNetworkAttrGroup_handler(netsnmp_mib_handler          *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info   *reqinfo,
             netsnmp_request_info         *requests)
{
    netsnmp_request_info  *request;
    netsnmp_variable_list *requestvb;
    oid      subid;

    /*
     * The cached data should already have been loaded by the
     *    cache handler, higher up the handler chain.
     * But just to be safe, check this and load it manually if necessary
     */

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        modEoCCBATNetworkAttrGroup_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

	for (request=requests; request; request=request->next) {
		requestvb = request->requestvb;
		subid = requestvb->name[OID_LENGTH(modEoCCBATNetworkAttrGroup_oid)];  /* XXX */

		HC_DBG_OID(requestvb);
		
		switch(subid){
			case MODEOCCBATADMINMACADDRESS:
				handle_modEoCCBATAdminMACAddress(handler, reginfo, reqinfo, request);
			  break;
			case MODEOCCBATADMINIPMODE:
				handle_modEoCCBATAdminIPMode(handler, reginfo, reqinfo, request);
			  break;
			case MODEOCCBATADMINIPADDRESS:
				handle_modEoCCBATAdminIPAddress(handler, reginfo, reqinfo, request);
			  break;
			case MODEOCCBATADMINIPMASK:
				handle_modEoCCBATAdminIPMask(handler, reginfo, reqinfo, request);				
			  break;
			case MODEOCCBATADMINIPGATEWAY:
				handle_modEoCCBATAdminIPGateway(handler, reginfo, reqinfo, request);				
			  break;
		}
	
	}

   return SNMP_ERR_NOERROR;
}



int modEoCCBATNetworkAttrGroup_load(netsnmp_cache *cache, void *vmagic)
{
    long            ret_value = -1;
	ret_value = ipc_get_sys_networking(&info);
	
    if (HC_IPC_ERROR(ret_value)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to load modEoCCBATNetworkAttrGroup Group\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded modEoCCBATNetworkAttrGroup Group\n"));
    }

	HC_IPC_ASSERT(ret_value);

    return ret_value;
}


void modEoCCBATNetworkAttrGroup_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL((DBGID, "Free modEoCCBATNetworkAttrGroup Group\n"));
}


void modEoCCBATNetworkAttrGroup_commit(unsigned int regNo, void *clientargs)
{
	long ret_value;
	ipc_network_t req;

	HC_VALID_ASSERT();

	memcpy(req.hostname, info.hostname, sizeof(req.hostname));
	req.ip_proto = info.ip_proto;
	memcpy(&req.netif, &info.netif, sizeof(req.netif));

	if (req.ip_proto == IP_PROTO_DYNAMIC){
		req.action = ACTION_RENEW;
	}

	ret_value = ipc_set_sys_networking(&req);
	if (HC_IPC_ERROR(ret_value)) {
		DEBUGMSGTL((DBGID, "Failed to commit modEoCCBATNetworkAttrGroup Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Commited modEoCCBATNetworkAttrGroup Group\n"));
	}

	HC_IPC_ASSERT1(ret_value);
}




