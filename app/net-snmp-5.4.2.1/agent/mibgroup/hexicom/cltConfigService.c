/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltConfigService.h"


#include "hexicomTC.h"

#ifndef DBGID
#define DBGID  "hc:cltservice"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltConfigService_commit, NULL)


static sys_security_t cltservice;


static oid	cltConfigService_oid[] = { HC_CLT_OBJ_OID, 2, 1, 4};


/** Initializes the cltConfigService module */
void
init_cltConfigService(void)
{
	netsnmp_handler_registration *reginfo;
	
	 /*
	  * register ourselves with the agent as a group of scalars...
	  */
		 
	 DEBUGMSGTL((DBGID, "Initializing\n"));
	
	 reginfo = netsnmp_create_handler_registration("cltConfigService", cltConfigService_handler,
			 cltConfigService_oid, OID_LENGTH(cltConfigService_oid), HANDLER_CAN_RWRITE);
	 
	 netsnmp_register_scalar_group(reginfo, CLTCONFIGMANAGEMENTVLAN, CLTCONFIGTELNETPORT);
	
	
	 netsnmp_inject_handler( reginfo,
			 netsnmp_get_cache_handler(  HC_CACHE_TIMEOUT,
					 cltConfigService_load, cltConfigService_free,
					 cltConfigService_oid, OID_LENGTH(cltConfigService_oid)));

}

int
handle_cltConfigManagementVLAN(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    int             ret, ipc_assert = 0;
	static int value = 0;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.mvlan;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
			break;
        }
		if (!vlan_exist(vb_int(requests->requestvb), &ipc_assert)){
			ret = SNMP_ERR_WRONGVALUE;
            netsnmp_set_request_error(reqinfo, requests, ret);			
			HC_IPC_ASSERT(ipc_assert);
		}
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
	   cltservice.mvlan = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigManagementVLAN\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigHTTPSAdminStatus(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.https_en ? TruthValue_true : TruthValue_false;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		cltservice.https_en = (vb_int(requests->requestvb) == TruthValue_true) ? 1 : 0;
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigHTTPSAdminStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigSSHAdminStatus(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.ssh_en ? TruthValue_true : TruthValue_false;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );

        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
	cltservice.ssh_en = (vb_int(requests->requestvb) == TruthValue_true) ? 1 : 0;

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigSSHAdminStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigSSHPort(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.ssh_port;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cltConfigSSHPort\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigTelnetAdminStatus(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.telnet_en ? TruthValue_true : TruthValue_false;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		cltservice.telnet_en = (vb_int(requests->requestvb) == TruthValue_true) ? 1 : 0;

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigTelnetAdminStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigTelnetPort(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = cltservice.telnet_port;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigTelnetPort\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int cltConfigService_handler(netsnmp_mib_handler          *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info   *reqinfo,
             netsnmp_request_info         *requests)
{
    netsnmp_request_info  *request;
    netsnmp_variable_list *requestvb;
    oid      subid;

    /*
     * The cached data should already have been loaded by the
     *    cache handler, higher up the handler chain.
     * But just to be safe, check this and load it manually if necessary
     */

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltConfigService_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

	for (request=requests; request; request=request->next) {
		requestvb = request->requestvb;
		subid = requestvb->name[OID_LENGTH(cltConfigService_oid)];  /* XXX */
		DEBUGMSGTL(( DBGID, "oid: "));
		DEBUGMSGOID((DBGID, requestvb->name, requestvb->name_length));
		DEBUGMSG((DBGID, "\n"));


		switch(subid){
		case CLTCONFIGMANAGEMENTVLAN:
			handle_cltConfigManagementVLAN(handler, reginfo, reqinfo, request);
			break;
		case CLTCONFIGHTTPSADMINSTATUS:
			handle_cltConfigHTTPSAdminStatus(handler, reginfo, reqinfo, request);
			break;
		case CLTCONFIGSSHADMINSTATUS:
			handle_cltConfigSSHAdminStatus(handler, reginfo, reqinfo, request);
			break;			
		case CLTCONFIGSSHPORT:
			handle_cltConfigSSHPort(handler, reginfo, reqinfo, request);
			break;
		case CLTCONFIGTELNETADMINSTATUS:
			handle_cltConfigTelnetAdminStatus(handler, reginfo, reqinfo, request);
			break;
		case CLTCONFIGTELNETPORT:
			handle_cltConfigTelnetPort(handler, reginfo, reqinfo, request);
			break;			
		}
	
	}

   return SNMP_ERR_NOERROR;
}



int cltConfigService_load(netsnmp_cache *cache, void *vmagic)
{

    long ret = -1;
	
	ret = ipc_get_sys_security(&cltservice);
	
    if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		memset(&cltservice, 0, sizeof(cltservice));
		DEBUGMSGTL((DBGID, "Failed to load cltConfigService Group\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded cltConfigService Group\n"));
    }

	HC_IPC_ASSERT(ret);

    return ret;
}


void cltConfigService_free(netsnmp_cache *cache, void *magic)
{

}


void cltConfigService_commit(unsigned int regNo, void *clientargs)
{
	long ret;

	HC_VALID_ASSERT();

	ret = ipc_set_sys_security(&cltservice, 0); // update all
	if (HC_IPC_ERROR(ret)) {
		DEBUGMSGTL((DBGID, "Failed to commit cltConfigService Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Commited cltConfigService Group\n"));
	}

	HC_IPC_ASSERT1(ret);	
}



