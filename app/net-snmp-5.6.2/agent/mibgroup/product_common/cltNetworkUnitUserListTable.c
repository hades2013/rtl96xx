/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltNetworkUnitUserListTable.h"

#include "ipc_interfaceTC.h"

#ifndef DBGID
#define DBGID  "hc:cltusertable"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltNetworkUnitUserListTable_commit, NULL)


/** Initializes the cltNetworkUnitUserListTable module */
void
init_cltNetworkUnitUserListTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_cltNetworkUnitUserListTable();
}

//# Determine the first/last column names

/** Initialize the cltNetworkUnitUserListTable table by defining its contents and how it's structured */
void
initialize_table_cltNetworkUnitUserListTable(void)
{
    static oid      cltNetworkUnitUserListTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 10 };
    size_t          cltNetworkUnitUserListTable_oid_len =
        OID_LENGTH(cltNetworkUnitUserListTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

	DEBUGMSGTL((DBGID, "Initializing\n"));

    reg =
        netsnmp_create_handler_registration("cltNetworkUnitUserListTable",
                                            cltNetworkUnitUserListTable_handler,
                                            cltNetworkUnitUserListTable_oid,
                                            cltNetworkUnitUserListTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: cltNetworkUnitUserListIndex */
                                     0);
    table_info->min_column = COLUMN_CLTNETWORKUNITUSERLISTINDEX;
    table_info->max_column = COLUMN_CLTNETWORKUNITUSERLISTROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        cltNetworkUnitUserListTable_get_first_data_point;
    iinfo->get_next_data_point =
        cltNetworkUnitUserListTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
			   		cltNetworkUnitUserListTable_load, cltNetworkUnitUserListTable_free,
					cltNetworkUnitUserListTable_oid, OID_LENGTH(cltNetworkUnitUserListTable_oid)));
    DEBUGMSGTL((DBGID,
                "initialize cltNetworkUnitUserListTable\n"));     

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct cltNetworkUnitUserListTable_entry {
    /*
     * Index values 
     */
    long            cltNetworkUnitUserListIndex;

    /*
     * Column values 
     */
 //   long            cltNetworkUnitUserListIndex;
    char            cltNetworkUnitUserListMACAddress[HC_MAC_ADDRESS_SIZE];
    size_t          cltNetworkUnitUserListMACAddress_len;
    char            old_cltNetworkUnitUserListMACAddress[HC_MAC_ADDRESS_SIZE];
    size_t          old_cltNetworkUnitUserListMACAddress_len;
    char            cltNetworkUnitUserListDeviceModel[HC_SYS_MODEL_SIZE];
    size_t          cltNetworkUnitUserListDeviceModel_len;
    char            old_cltNetworkUnitUserListDeviceModel[HC_SYS_MODEL_SIZE];
    size_t          old_cltNetworkUnitUserListDeviceModel_len;
    long            cltNetworkUnitUserListTemplateID;
    long            old_cltNetworkUnitUserListTemplateID;
    char            cltNetworkUnitUserListName[HC_SYS_NAME_SIZE];
    size_t          cltNetworkUnitUserListName_len;
    char            old_cltNetworkUnitUserListName[HC_SYS_NAME_SIZE];
    size_t          old_cltNetworkUnitUserListName_len;
    char            cltNetworkUnitUserListDescription[HC_SYS_DESC_SIZE];
    size_t          cltNetworkUnitUserListDescription_len;
    char            old_cltNetworkUnitUserListDescription[HC_SYS_DESC_SIZE];
    size_t          old_cltNetworkUnitUserListDescription_len;
    long            cltNetworkUnitUserListRowStatus;
    long            old_cltNetworkUnitUserListRowStatus;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct cltNetworkUnitUserListTable_entry *next;
};

struct cltNetworkUnitUserListTable_entry *cltNetworkUnitUserListTable_head = NULL;
struct cltNetworkUnitUserListTable_entry *cltNetworkUnitUserListTable_commit_head = NULL;
struct cltNetworkUnitUserListTable_entry *cltNetworkUnitUserListTable_creating_head = NULL;


/*
 * create a new row in the (unsorted) table 
 */
struct cltNetworkUnitUserListTable_entry *
cltNetworkUnitUserListTable_createEntry(long cltNetworkUnitUserListIndex,
	struct cltNetworkUnitUserListTable_entry *cltNetworkUnitUserListTable)
{
    struct cltNetworkUnitUserListTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltNetworkUnitUserListTable_entry);
    if (!entry)
        return NULL;

	memcpy(entry, cltNetworkUnitUserListTable, sizeof(*entry));

    entry->cltNetworkUnitUserListIndex = cltNetworkUnitUserListIndex;
    entry->next = cltNetworkUnitUserListTable_head;
    cltNetworkUnitUserListTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
cltNetworkUnitUserListTable_removeEntry(struct
                                        cltNetworkUnitUserListTable_entry
                                        *entry)
{
    struct cltNetworkUnitUserListTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = cltNetworkUnitUserListTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltNetworkUnitUserListTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


void cltNetworkUnitUserListTable_removeAllEntry(void )
{
    struct cltNetworkUnitUserListTable_entry *ptr, *pnext;

    for (ptr = cltNetworkUnitUserListTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltNetworkUnitUserListTable_head = NULL;
}


void cltNetworkUnitUserListTable_setEntry(
				struct cltNetworkUnitUserListTable_entry *entry, 
				cnu_user_config_t *user)
{
	memcpy(entry->cltNetworkUnitUserListMACAddress, user->mac.octet, sizeof(ether_addr_t));
	entry->cltNetworkUnitUserListMACAddress_len  = sizeof(ether_addr_t);
	DBG_ASSERT(user->device_id < supported_devices_num, "Invalid device id in userlist");
	safe_strncpy(entry->cltNetworkUnitUserListDeviceModel, supported_devices_alias(user->device_id), sizeof(entry->cltNetworkUnitUserListDeviceModel));
	entry->cltNetworkUnitUserListDeviceModel_len = strlen(entry->cltNetworkUnitUserListDeviceModel);
	entry->cltNetworkUnitUserListTemplateID = user->tmpl_id + 1;
	safe_strncpy(entry->cltNetworkUnitUserListName, user->name, sizeof(entry->cltNetworkUnitUserListName));
	entry->cltNetworkUnitUserListName_len = strlen(entry->cltNetworkUnitUserListName);
	safe_strncpy(entry->cltNetworkUnitUserListDescription, user->desc, sizeof(entry->cltNetworkUnitUserListDescription));
	entry->cltNetworkUnitUserListDescription_len = strlen(entry->cltNetworkUnitUserListDescription);
	entry->cltNetworkUnitUserListRowStatus = (user->auth == CNU_AUTH_ACCEPT) ? USERRowStatus_white : USERRowStatus_black;
}

struct cltNetworkUnitUserListTable_entry *
cltNetworkUnitUserListTable_backupCommitEntry(
				struct cltNetworkUnitUserListTable_entry *cltNetworkUnitUserListTable)
{
    struct cltNetworkUnitUserListTable_entry *entry, *next;

    for (entry = cltNetworkUnitUserListTable_commit_head; entry != NULL; entry = entry->next) {
		if (entry->cltNetworkUnitUserListIndex == cltNetworkUnitUserListTable->cltNetworkUnitUserListIndex){
			break;
		}		
    }	

	if (!entry){
		entry = SNMP_MALLOC_TYPEDEF(struct cltNetworkUnitUserListTable_entry);
		if (!entry)
			return NULL;
		entry->next = cltNetworkUnitUserListTable_commit_head;
		cltNetworkUnitUserListTable_commit_head = entry;
	}

	
	next = entry->next;
	memcpy(entry, cltNetworkUnitUserListTable, sizeof(*entry));
	entry->next = next;
	
    return entry;	
}


void cltNetworkUnitUserListTable_removeAllCommitEntry(void )
{
    struct cltNetworkUnitUserListTable_entry *ptr, *pnext;

    for (ptr = cltNetworkUnitUserListTable_commit_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltNetworkUnitUserListTable_commit_head = NULL;
}

void cltNetworkUnitUserListTable_createCreatingEntry(long cltNetworkUnitUserListIndex )
{
    struct cltNetworkUnitUserListTable_entry *entry;
	cnu_user_config_t user;

    entry = SNMP_MALLOC_TYPEDEF(struct cltNetworkUnitUserListTable_entry);
    if (!entry)
        return ;

	device_userlist_default(&user);

	cltNetworkUnitUserListTable_setEntry(entry, &user);
	entry->cltNetworkUnitUserListRowStatus = USERRowStatus_createAndWait;
    entry->cltNetworkUnitUserListIndex = cltNetworkUnitUserListIndex;
    entry->next = cltNetworkUnitUserListTable_creating_head;
    cltNetworkUnitUserListTable_creating_head = entry;
}



void cltNetworkUnitUserListTable_removeAllCreatingEntry(void )
{
    struct cltNetworkUnitUserListTable_entry *ptr, *pnext;

    for (ptr = cltNetworkUnitUserListTable_creating_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltNetworkUnitUserListTable_creating_head = NULL;
}



void cltNetworkUnitUserListTable_removeCreatingEntry(long cltNetworkUnitUserListIndex)
{
    struct cltNetworkUnitUserListTable_entry *ptr, *prev;

    for (ptr = cltNetworkUnitUserListTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr->cltNetworkUnitUserListIndex == cltNetworkUnitUserListIndex)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltNetworkUnitUserListTable_creating_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(ptr);   
}





/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
cltNetworkUnitUserListTable_get_first_data_point(void **my_loop_context,
                                                 void **my_data_context,
                                                 netsnmp_variable_list *
                                                 put_index_data,
                                                 netsnmp_iterator_info
                                                 *mydata)
{
    *my_loop_context = cltNetworkUnitUserListTable_head;
    return cltNetworkUnitUserListTable_get_next_data_point(my_loop_context,
                                                           my_data_context,
                                                           put_index_data,
                                                           mydata);
}

netsnmp_variable_list *
cltNetworkUnitUserListTable_get_next_data_point(void **my_loop_context,
                                                void **my_data_context,
                                                netsnmp_variable_list *
                                                put_index_data,
                                                netsnmp_iterator_info
                                                *mydata)
{
    struct cltNetworkUnitUserListTable_entry *entry =
        (struct cltNetworkUnitUserListTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->cltNetworkUnitUserListIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the cltNetworkUnitUserListTable table */
int
cltNetworkUnitUserListTable_handler(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
	int ret;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct cltNetworkUnitUserListTable_entry *table_entry;

	netsnmp_variable_list *requestvb;	

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltNetworkUnitUserListTable_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltNetworkUnitUserListTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	


            switch (table_info->colnum) {
            case COLUMN_CLTNETWORKUNITUSERLISTINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltNetworkUnitUserListIndex);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTMACADDRESS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltNetworkUnitUserListMACAddress,
                                         table_entry->
                                         cltNetworkUnitUserListMACAddress_len);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDEVICEMODEL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltNetworkUnitUserListDeviceModel,
                                         table_entry->
                                         cltNetworkUnitUserListDeviceModel_len);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTTEMPLATEID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltNetworkUnitUserListTemplateID);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltNetworkUnitUserListName,
                                         table_entry->
                                         cltNetworkUnitUserListName_len);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDESCRIPTION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltNetworkUnitUserListDescription,
                                         table_entry->
                                         cltNetworkUnitUserListDescription_len);
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltNetworkUnitUserListRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltNetworkUnitUserListTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTNETWORKUNITUSERLISTMACADDRESS:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       HC_MAC_ADDRESS_SIZE);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }

				{
					ether_addr_t addr;
					memcpy(addr.octet, request->requestvb->val.string, sizeof(ether_addr_t));
					if (!valid_unicast_mac(&addr)){
						netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
						return SNMP_ERR_NOERROR;	
					}
				}
	
				
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDEVICEMODEL:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              cltNetworkUnitUserListDeviceModel));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!valid_device_alias(vb_strdup(request->requestvb))){
                   	netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;				
				}
				
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTTEMPLATEID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int_range(request->requestvb, 1, device_templates_num);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTNAME:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       HC_MAX_USER_NAME_SIZE);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }

				if (!valid_xname(vb_strdup(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}				
				
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDESCRIPTION:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       HC_MAX_USER_DESC_SIZE);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!valid_description(vb_strdup(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
				
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTROWSTATUS:
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!validUSERRowStatus(vb_int(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
				
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltNetworkUnitUserListTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTNETWORKUNITUSERLISTMACADDRESS:
                memcpy(table_entry->old_cltNetworkUnitUserListMACAddress,
                       table_entry->cltNetworkUnitUserListMACAddress,
                       sizeof(table_entry->
                              cltNetworkUnitUserListMACAddress));
                table_entry->old_cltNetworkUnitUserListMACAddress_len =
                    table_entry->cltNetworkUnitUserListMACAddress_len;
                memset(table_entry->cltNetworkUnitUserListMACAddress, 0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListMACAddress));
                memcpy(table_entry->cltNetworkUnitUserListMACAddress,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltNetworkUnitUserListMACAddress_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDEVICEMODEL:
                memcpy(table_entry->old_cltNetworkUnitUserListDeviceModel,
                       table_entry->cltNetworkUnitUserListDeviceModel,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDeviceModel));
                table_entry->old_cltNetworkUnitUserListDeviceModel_len =
                    table_entry->cltNetworkUnitUserListDeviceModel_len;
                memset(table_entry->cltNetworkUnitUserListDeviceModel, 0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDeviceModel));
                memcpy(table_entry->cltNetworkUnitUserListDeviceModel,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltNetworkUnitUserListDeviceModel_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTTEMPLATEID:
                table_entry->old_cltNetworkUnitUserListTemplateID =
                    table_entry->cltNetworkUnitUserListTemplateID;
                table_entry->cltNetworkUnitUserListTemplateID =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTNAME:
                memcpy(table_entry->old_cltNetworkUnitUserListName,
                       table_entry->cltNetworkUnitUserListName,
                       sizeof(table_entry->cltNetworkUnitUserListName));
                table_entry->old_cltNetworkUnitUserListName_len =
                    table_entry->cltNetworkUnitUserListName_len;
                memset(table_entry->cltNetworkUnitUserListName, 0,
                       sizeof(table_entry->cltNetworkUnitUserListName));
                memcpy(table_entry->cltNetworkUnitUserListName,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltNetworkUnitUserListName_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDESCRIPTION:
                memcpy(table_entry->old_cltNetworkUnitUserListDescription,
                       table_entry->cltNetworkUnitUserListDescription,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDescription));
                table_entry->old_cltNetworkUnitUserListDescription_len =
                    table_entry->cltNetworkUnitUserListDescription_len;
                memset(table_entry->cltNetworkUnitUserListDescription, 0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDescription));
                memcpy(table_entry->cltNetworkUnitUserListDescription,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltNetworkUnitUserListDescription_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTROWSTATUS:
                table_entry->old_cltNetworkUnitUserListRowStatus =
                    table_entry->cltNetworkUnitUserListRowStatus;
                table_entry->cltNetworkUnitUserListRowStatus =
                    *request->requestvb->val.integer;
				break;
            }
			cltNetworkUnitUserListTable_backupCommitEntry(table_entry);			
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltNetworkUnitUserListTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTNETWORKUNITUSERLISTMACADDRESS:
                memcpy(table_entry->cltNetworkUnitUserListMACAddress,
                       table_entry->old_cltNetworkUnitUserListMACAddress,
                       sizeof(table_entry->
                              cltNetworkUnitUserListMACAddress));
                memset(table_entry->old_cltNetworkUnitUserListMACAddress,
                       0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListMACAddress));
                table_entry->cltNetworkUnitUserListMACAddress_len =
                    table_entry->old_cltNetworkUnitUserListMACAddress_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDEVICEMODEL:
                memcpy(table_entry->cltNetworkUnitUserListDeviceModel,
                       table_entry->old_cltNetworkUnitUserListDeviceModel,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDeviceModel));
                memset(table_entry->old_cltNetworkUnitUserListDeviceModel,
                       0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDeviceModel));
                table_entry->cltNetworkUnitUserListDeviceModel_len =
                    table_entry->old_cltNetworkUnitUserListDeviceModel_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTTEMPLATEID:
                table_entry->cltNetworkUnitUserListTemplateID =
                    table_entry->old_cltNetworkUnitUserListTemplateID;
                table_entry->old_cltNetworkUnitUserListTemplateID = 0;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTNAME:
                memcpy(table_entry->cltNetworkUnitUserListName,
                       table_entry->old_cltNetworkUnitUserListName,
                       sizeof(table_entry->cltNetworkUnitUserListName));
                memset(table_entry->old_cltNetworkUnitUserListName, 0,
                       sizeof(table_entry->cltNetworkUnitUserListName));
                table_entry->cltNetworkUnitUserListName_len =
                    table_entry->old_cltNetworkUnitUserListName_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTDESCRIPTION:
                memcpy(table_entry->cltNetworkUnitUserListDescription,
                       table_entry->old_cltNetworkUnitUserListDescription,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDescription));
                memset(table_entry->old_cltNetworkUnitUserListDescription,
                       0,
                       sizeof(table_entry->
                              cltNetworkUnitUserListDescription));
                table_entry->cltNetworkUnitUserListDescription_len =
                    table_entry->old_cltNetworkUnitUserListDescription_len;
                break;
            case COLUMN_CLTNETWORKUNITUSERLISTROWSTATUS:
                 table_entry->cltNetworkUnitUserListRowStatus =
                    table_entry->old_cltNetworkUnitUserListRowStatus;
                table_entry->old_cltNetworkUnitUserListRowStatus = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
		local_commit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int cltNetworkUnitUserListTable_load(netsnmp_cache *cache, void *vmagic)
{

	long			ret = -1, i;
	struct cltNetworkUnitUserListTable_entry entry, *ptr;   


	ret = device_userlists_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltNetworkUnitUserListTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltNetworkUnitUserListTable Group\n"));
	}

	HC_IPC_ASSERT(ret);    

	ret = device_templates_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltNetworkUnitUserListTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltNetworkUnitUserListTable Group\n"));
	}

	HC_IPC_ASSERT(ret);    

	for (i = 0; i < device_userlists_num; i ++){
		 cltNetworkUnitUserListTable_setEntry(&entry, &device_userlists[i]);
		 cltNetworkUnitUserListTable_createEntry(i + 1, &entry);
	}

	if ((device_userlists_num == 0) 
		&& (cltNetworkUnitUserListTable_creating_head == NULL)){
		cltNetworkUnitUserListTable_createCreatingEntry(0);
	}

	for (ptr = cltNetworkUnitUserListTable_creating_head; ptr != NULL; ptr = ptr->next, i ++)
	{
		ptr->cltNetworkUnitUserListIndex = i + 1;
		cltNetworkUnitUserListTable_createEntry(i + 1, ptr);		
	}
	
	return ret; 
} 

void cltNetworkUnitUserListTable_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL((DBGID, "Free cltNetworkUnitUserListTable Group\n"));  
	
	cltNetworkUnitUserListTable_removeAllEntry();
}

cnu_user_config_t *cltNetworkUnitUserListTable_change_and_update(struct cltNetworkUnitUserListTable_entry *entry)
{
	static cnu_user_config_t user_c, *user;
	int user_id = entry->cltNetworkUnitUserListIndex - 1;
	int new_user = 0;

	user = &user_c;

	if (user_id < device_userlists_num){
		memcpy(user, &device_userlists[user_id], sizeof(*user));
	}else {
		new_user = 1;
		snmp_log(LOG_INFO, "user_id >= device_userlists_num, is a new user\n");
	}

	memcpy(user->mac.octet, entry->cltNetworkUnitUserListMACAddress, sizeof(ether_addr_t));
	safe_strncpy(user->name, entry->cltNetworkUnitUserListName, sizeof(user->name));
	safe_strncpy(user->desc, entry->cltNetworkUnitUserListDescription, sizeof(user->desc));
	user->device_id = supported_devices_id_b0(entry->cltNetworkUnitUserListDeviceModel);	
	DBG_ASSERT((user->device_id < supported_devices_num), "Invalid device alias!");
	if (entry->cltNetworkUnitUserListRowStatus == USERRowStatus_white){
		user->auth = CNU_AUTH_ACCEPT;
	}else if (entry->cltNetworkUnitUserListRowStatus == USERRowStatus_black){
		user->auth = CNU_AUTH_DENY;
	}
	if (!new_user && !memcmp(user, &device_userlists[user_id], sizeof(*user))){
		// no change
		return NULL;
	}
	
	return user;
}


void cltNetworkUnitUserListTable_commit(unsigned int regNo, void *clientargs)
{

	long ret;
    struct cltNetworkUnitUserListTable_entry *ptr;
	cnu_user_config_t userlists[EOC_MAX_USER_NUMS], *user;
	int do_num = 0;
	
	HC_VALID_ASSERT();


// Delete if any
    for (ptr = cltNetworkUnitUserListTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if (ptr->cltNetworkUnitUserListRowStatus == USERRowStatus_destroy){
			if (ptr->old_cltNetworkUnitUserListRowStatus == USERRowStatus_createAndWait){
				//cltNetworkUnitUserListTable_removeAllCreatingEntry();

				cltNetworkUnitUserListTable_removeCreatingEntry(ptr->cltNetworkUnitUserListIndex);
			}else {
				userlists[do_num].user_id = ptr->cltNetworkUnitUserListIndex - 1;
				do_num ++;
			}
		}
    }

	if (do_num){
		ret = ipc_del_userlist(userlists, do_num);
		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to delete cltNetworkUnitUserListTable Group\n"));
		} else {
			DEBUGMSGTL((DBGID, "Deleted cltNetworkUnitUserListTable Group\n"));
		}
		HC_IPC_ASSERT1(ret);			
		return ;
	}

// creat  if any
    for (ptr = cltNetworkUnitUserListTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if ((ptr->cltNetworkUnitUserListRowStatus == USERRowStatus_createAndWait)
			&& (ptr->old_cltNetworkUnitUserListRowStatus != USERRowStatus_createAndWait) 
			&& (cltNetworkUnitUserListTable_creating_head == NULL)){

			cltNetworkUnitUserListTable_createCreatingEntry(0);
/*
			ret = ipc_new_userlist(1);
			if (HC_IPC_ERROR(ret)) {
				DEBUGMSGTL((DBGID, "Failed to new cltNetworkUnitUserListTable Group\n"));
			} else {
				DEBUGMSGTL((DBGID, "Newed cltNetworkUnitUserListTable Group\n"));
			}
			HC_IPC_ASSERT1(ret);	
			*/
			return ;
		}
    }
	
	// apply all changes
#if 0
	ret = device_userlists_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltNetworkUnitUserListTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltNetworkUnitUserListTable Group\n"));
	}
	
	HC_IPC_ASSERT1(ret);	
#endif	

    for (ptr = cltNetworkUnitUserListTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if ((ptr->old_cltNetworkUnitUserListRowStatus == USERRowStatus_createAndWait) 
			&& ((ptr->cltNetworkUnitUserListRowStatus == USERRowStatus_black)
			|| (ptr->old_cltNetworkUnitUserListRowStatus == USERRowStatus_white))){
			user = cltNetworkUnitUserListTable_change_and_update(ptr);
			if (user && valid_userlist(user)){
				cltNetworkUnitUserListTable_removeCreatingEntry(ptr->cltNetworkUnitUserListIndex);				
				memcpy(&userlists[do_num], user, sizeof(*user));
				do_num ++;
			}
		}else {
			user = cltNetworkUnitUserListTable_change_and_update(ptr);
			if (user){
				memcpy(&userlists[do_num], user, sizeof(*user));
				do_num ++;
			}
		}
    }


	cltNetworkUnitUserListTable_removeAllCommitEntry();


	if (do_num){
		ret = ipc_new_userlist(userlists, do_num);
		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to commit cltNetworkUnitUserListTable Group\n"));
		} else {
			DEBUGMSGTL((DBGID, "Commited cltNetworkUnitUserListTable Group\n"));
		}		
		HC_IPC_ASSERT1(ret);
	} 
}




