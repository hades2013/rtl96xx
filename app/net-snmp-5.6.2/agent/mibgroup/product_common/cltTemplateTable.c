/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltTemplateTable.h"

#include "ipc_interfaceTC.h"

#ifndef DBGID
#define DBGID  "hc:clttmpltable"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltTemplateTable_commit, NULL)



/** Initializes the cltTemplateTable module */
void
init_cltTemplateTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_cltTemplateTable();
}

//# Determine the first/last column names

/** Initialize the cltTemplateTable table by defining its contents and how it's structured */
void
initialize_table_cltTemplateTable(void)
{
    static oid      cltTemplateTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 2, 2 };
    size_t          cltTemplateTable_oid_len =
        OID_LENGTH(cltTemplateTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

	DEBUGMSGTL((DBGID, "Initializing\n"));

    reg =
        netsnmp_create_handler_registration("cltTemplateTable",
                                            cltTemplateTable_handler,
                                            cltTemplateTable_oid,
                                            cltTemplateTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: cltTemplateIndex */
                                     0);
    table_info->min_column = COLUMN_CLTTEMPLATEINDEX;
    table_info->max_column = COLUMN_CLTTEMPLATECABLEPVID;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = cltTemplateTable_get_first_data_point;
    iinfo->get_next_data_point = cltTemplateTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
			   		cltTemplateTable_load, cltTemplateTable_free,
					cltTemplateTable_oid, OID_LENGTH(cltTemplateTable_oid)));
    DEBUGMSGTL((DBGID,
                "initialize cltTemplateTable\n"));    

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct cltTemplateTable_entry {
    /*
     * Index values 
     */
    long            cltTemplateIndex;

    /*
     * Column values 
     */
//    long            cltTemplateIndex;
    char            cltTemplateName[HC_SYS_NAME_SIZE];
    size_t          cltTemplateName_len;
    char            old_cltTemplateName[HC_SYS_NAME_SIZE];
    size_t          old_cltTemplateName_len;
    char            cltTemplateDescription[HC_SYS_DESC_SIZE];
    size_t          cltTemplateDescription_len;
    char            old_cltTemplateDescription[HC_SYS_DESC_SIZE];
    size_t          old_cltTemplateDescription_len;
    char            cltTemplateDeviceModelName[HC_SYS_MODEL_SIZE];
    size_t          cltTemplateDeviceModelName_len;
    char            old_cltTemplateDeviceModelName[HC_SYS_MODEL_SIZE];
    size_t          old_cltTemplateDeviceModelName_len;
    long            cltTemplateRowStatus;
    long            old_cltTemplateRowStatus;
    long            cltTemplateStormFilterEnable;
    long            old_cltTemplateStormFilterEnable;
    long            cltTemplateMACLimitation;
    long            old_cltTemplateMACLimitation;
    long            cltTemplateEthernetIfNumber;
    long            cltTemplateCableUpRateLimitation;
    long            old_cltTemplateCableUpRateLimitation;
    long            cltTemplateCableDownRateLimitation;
    long            old_cltTemplateCableDownRateLimitation;
    long            cltTemplateCableVLANMode;
    long            old_cltTemplateCableVLANMode;
    long            cltTemplateCablePVID;
    long            old_cltTemplateCablePVID;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct cltTemplateTable_entry *next;
};

struct cltTemplateTable_entry *cltTemplateTable_head;

struct cltTemplateTable_entry *cltTemplateTable_commit_head = NULL;


/*
 * create a new row in the (unsorted) table 
 */
struct cltTemplateTable_entry *
cltTemplateTable_createEntry(long cltTemplateIndex,
			struct cltTemplateTable_entry *cltTemplateTable)
{
    struct cltTemplateTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltTemplateTable_entry);
    if (!entry)
        return NULL;

	memcpy(entry, cltTemplateTable, sizeof(*entry));

    entry->cltTemplateIndex = cltTemplateIndex;
    entry->next = cltTemplateTable_head;
    cltTemplateTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
cltTemplateTable_removeEntry(struct cltTemplateTable_entry *entry)
{
    struct cltTemplateTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = cltTemplateTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltTemplateTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void cltTemplateTable_removeAllEntry(void )
{
    struct cltTemplateTable_entry *ptr, *pnext;

    for (ptr = cltTemplateTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltTemplateTable_head = NULL;
}

struct cltTemplateTable_entry *
cltTemplateTable_getEntry(long cltTemplateIndex)
{
	struct cltTemplateTable_entry *ptr;
	
    for (ptr = cltTemplateTable_head;ptr != NULL; ptr = ptr->next) {
		if (ptr->cltTemplateIndex == cltTemplateIndex){
			return ptr;
		}
    }	
	return NULL;
}


void cltTemplateTable_setEntry(
				struct cltTemplateTable_entry *entry, 
				ipc_service_template_t *tmpl)
{
	safe_strncpy(entry->cltTemplateName, tmpl->tmpl_name, sizeof(entry->cltTemplateName));
	entry->cltTemplateName_len = strlen(entry->cltTemplateName);
	safe_strncpy(entry->cltTemplateDescription, tmpl->tmpl_desc, sizeof(entry->cltTemplateDescription));
	entry->cltTemplateDescription_len = strlen(entry->cltTemplateDescription);	
	safe_strncpy(entry->cltTemplateDeviceModelName, supported_devices_alias(tmpl->device_id), sizeof(entry->cltTemplateDeviceModelName));
	entry->cltTemplateDeviceModelName_len = strlen(entry->cltTemplateDeviceModelName);	
	entry->cltTemplateRowStatus = RowStatus_active;
	entry->cltTemplateMACLimitation = tmpl->mac_limit;
	DBG_ASSERT((tmpl->device_id < supported_devices_num), "Invalid device ID in template");
	if (tmpl->device_id < supported_devices_num){
		entry->cltTemplateEthernetIfNumber = supported_devices[tmpl->device_id].ports - 1;// remove cable port
	}else {
		entry->cltTemplateEthernetIfNumber = 0;	
		snmp_log(LOG_ERR, "Invalid device ID in template\n");
	}
	entry->cltTemplateCableUpRateLimitation = tmpl->cable_rate_up;
	entry->cltTemplateCableDownRateLimitation = tmpl->cable_rate_dn;
	entry->cltTemplateCableVLANMode = (tmpl->lsw_cfg.cab_port.tagged == 1) ? VLANTAG_tagged : VLANTAG_untagged;
	entry->cltTemplateCablePVID = tmpl->lsw_cfg.cab_port.pvid;
	entry->cltTemplateStormFilterEnable = tmpl->lsw_cfg.broadcast_storm ? TruthValue_true : TruthValue_false;
}

struct cltTemplateTable_entry *
cltTemplateTable_backupCommitEntry(
				struct cltTemplateTable_entry *cltTemplateTable)
{
    struct cltTemplateTable_entry *entry, *next;

    for (entry = cltTemplateTable_commit_head; entry != NULL; entry = entry->next) {
		if (entry->cltTemplateIndex == cltTemplateTable->cltTemplateIndex){
			break;
		}		
    }	

	if (!entry){
		entry = SNMP_MALLOC_TYPEDEF(struct cltTemplateTable_entry);
		if (!entry)
			return NULL;
		entry->next = cltTemplateTable_commit_head;
		cltTemplateTable_commit_head = entry;
	}

	
	next = entry->next;
	memcpy(entry, cltTemplateTable, sizeof(*entry));
	entry->next = next;
	
    return entry;	
}


void cltTemplateTable_removeAllCommitEntry(void )
{
    struct cltTemplateTable_entry *ptr, *pnext;

    for (ptr = cltTemplateTable_commit_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltTemplateTable_commit_head = NULL;
}



/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
cltTemplateTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    *my_loop_context = cltTemplateTable_head;
    return cltTemplateTable_get_next_data_point(my_loop_context,
                                                my_data_context,
                                                put_index_data, mydata);
}

netsnmp_variable_list *
cltTemplateTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    struct cltTemplateTable_entry *entry =
        (struct cltTemplateTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->cltTemplateIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the cltTemplateTable table */
int
cltTemplateTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
	int ret;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct cltTemplateTable_entry *table_entry;
	netsnmp_variable_list *requestvb;	

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltTemplateTable_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltTemplateTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTTEMPLATEINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltTemplateIndex);
                break;
            case COLUMN_CLTTEMPLATENAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltTemplateName,
                                         table_entry->cltTemplateName_len);
                break;
            case COLUMN_CLTTEMPLATEDESCRIPTION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltTemplateDescription,
                                         table_entry->
                                         cltTemplateDescription_len);
                break;
            case COLUMN_CLTTEMPLATEDEVICEMODELNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltTemplateDeviceModelName,
                                         table_entry->
                                         cltTemplateDeviceModelName_len);
                break;
            case COLUMN_CLTTEMPLATEROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateRowStatus);
                break;
            case COLUMN_CLTTEMPLATESTORMFILTERENABLE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateStormFilterEnable);
                break;
            case COLUMN_CLTTEMPLATEMACLIMITATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateMACLimitation);
                break;
            case COLUMN_CLTTEMPLATEETHERNETIFNUMBER:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateEthernetIfNumber);
                break;
            case COLUMN_CLTTEMPLATECABLEUPRATELIMITATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateCableUpRateLimitation);
                break;
            case COLUMN_CLTTEMPLATECABLEDOWNRATELIMITATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateCableDownRateLimitation);
                break;
            case COLUMN_CLTTEMPLATECABLEVLANMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateCableVLANMode);
                break;
            case COLUMN_CLTTEMPLATECABLEPVID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltTemplateCablePVID);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltTemplateTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTTEMPLATENAME:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       HC_MAX_TMPL_NAME_SIZE);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (default_template(table_entry->cltTemplateIndex) || !valid_template_name(vb_strdup(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
				
                break;
            case COLUMN_CLTTEMPLATEDESCRIPTION:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       HC_MAX_TMPL_DESC_SIZE);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (default_template(table_entry->cltTemplateIndex) || !valid_description(vb_strdup(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
				
                break;
            case COLUMN_CLTTEMPLATEDEVICEMODELNAME:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type(request->requestvb,
                                                       ASN_OCTET_STR);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (default_template(table_entry->cltTemplateIndex) || !valid_device_alias(vb_strdup(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
				
                break;
            case COLUMN_CLTTEMPLATEROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                                                 (table_entry ? RS_ACTIVE :
                                                  RS_NONEXISTENT));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (default_template(table_entry->cltTemplateIndex)){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}				
                break;
            case COLUMN_CLTTEMPLATESTORMFILTERENABLE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_truthvalue(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTTEMPLATEMACLIMITATION:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int_range(request->requestvb, 0, 255);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTTEMPLATECABLEUPRATELIMITATION:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int_range(request->requestvb, 0, 16384);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTTEMPLATECABLEDOWNRATELIMITATION:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int_range(request->requestvb, 0, 16384);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTTEMPLATECABLEVLANMODE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!validVLANTAG(vb_int(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;	
				}
				
                break;
            case COLUMN_CLTTEMPLATECABLEPVID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int_range(request->requestvb, 1 , 4094);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltTemplateTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTTEMPLATENAME:
               /* memcpy(table_entry->old_cltTemplateName,
                       table_entry->cltTemplateName,
                       sizeof(table_entry->cltTemplateName));
                table_entry->old_cltTemplateName_len =
                    table_entry->cltTemplateName_len;*/
                memset(table_entry->cltTemplateName, 0,
                       sizeof(table_entry->cltTemplateName));
                memcpy(table_entry->cltTemplateName,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltTemplateName_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTTEMPLATEDESCRIPTION:
                /*memcpy(table_entry->old_cltTemplateDescription,
                       table_entry->cltTemplateDescription,
                       sizeof(table_entry->cltTemplateDescription));
                table_entry->old_cltTemplateDescription_len =
                    table_entry->cltTemplateDescription_len;*/
                memset(table_entry->cltTemplateDescription, 0,
                       sizeof(table_entry->cltTemplateDescription));
                memcpy(table_entry->cltTemplateDescription,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltTemplateDescription_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTTEMPLATEDEVICEMODELNAME:
   /*             memcpy(table_entry->old_cltTemplateDeviceModelName,
                       table_entry->cltTemplateDeviceModelName,
                       sizeof(table_entry->cltTemplateDeviceModelName));
                table_entry->old_cltTemplateDeviceModelName_len =
                    table_entry->cltTemplateDeviceModelName_len;*/
                memset(table_entry->cltTemplateDeviceModelName, 0,
                       sizeof(table_entry->cltTemplateDeviceModelName));
                memcpy(table_entry->cltTemplateDeviceModelName,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltTemplateDeviceModelName_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTTEMPLATEROWSTATUS:
               table_entry->old_cltTemplateRowStatus =
                    table_entry->cltTemplateRowStatus;
                table_entry->cltTemplateRowStatus =
                    *request->requestvb->val.integer;
                break;				
            case COLUMN_CLTTEMPLATESTORMFILTERENABLE:
/*                table_entry->old_cltTemplateStormFilterEnable =
                    table_entry->cltTemplateStormFilterEnable;*/
                table_entry->cltTemplateStormFilterEnable =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTTEMPLATEMACLIMITATION:
/*                table_entry->old_cltTemplateMACLimitation =
                    table_entry->cltTemplateMACLimitation;*/
                table_entry->cltTemplateMACLimitation =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTTEMPLATECABLEUPRATELIMITATION:
/*                table_entry->old_cltTemplateCableUpRateLimitation =
                    table_entry->cltTemplateCableUpRateLimitation;*/
                table_entry->cltTemplateCableUpRateLimitation =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTTEMPLATECABLEDOWNRATELIMITATION:
/*                table_entry->old_cltTemplateCableDownRateLimitation =
                    table_entry->cltTemplateCableDownRateLimitation;*/
                table_entry->cltTemplateCableDownRateLimitation =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTTEMPLATECABLEVLANMODE:
/*                table_entry->old_cltTemplateCableVLANMode =
                    table_entry->cltTemplateCableVLANMode;*/
                table_entry->cltTemplateCableVLANMode =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTTEMPLATECABLEPVID:
/*                table_entry->old_cltTemplateCablePVID =
                    table_entry->cltTemplateCablePVID;*/
                table_entry->cltTemplateCablePVID =
                    *request->requestvb->val.integer;
                break;
            }
			cltTemplateTable_backupCommitEntry(table_entry);
        }
        /*
         * Check the internal consistency of an active row 
         
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltTemplateTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTTEMPLATEROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if ( 0 ) {
                        netsnmp_set_request_error(reqinfo, request,
                                                  SNMP_ERR_INCONSISTENTVALUE);
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }*/
        break;

    case MODE_SET_UNDO:/*
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltTemplateTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTTEMPLATENAME:
                memcpy(table_entry->cltTemplateName,
                       table_entry->old_cltTemplateName,
                       sizeof(table_entry->cltTemplateName));
                memset(table_entry->old_cltTemplateName, 0,
                       sizeof(table_entry->cltTemplateName));
                table_entry->cltTemplateName_len =
                    table_entry->old_cltTemplateName_len;
                break;
            case COLUMN_CLTTEMPLATEDESCRIPTION:
                memcpy(table_entry->cltTemplateDescription,
                       table_entry->old_cltTemplateDescription,
                       sizeof(table_entry->cltTemplateDescription));
                memset(table_entry->old_cltTemplateDescription, 0,
                       sizeof(table_entry->cltTemplateDescription));
                table_entry->cltTemplateDescription_len =
                    table_entry->old_cltTemplateDescription_len;
                break;
            case COLUMN_CLTTEMPLATEDEVICEMODELNAME:
                memcpy(table_entry->cltTemplateDeviceModelName,
                       table_entry->old_cltTemplateDeviceModelName,
                       sizeof(table_entry->cltTemplateDeviceModelName));
                memset(table_entry->old_cltTemplateDeviceModelName, 0,
                       sizeof(table_entry->cltTemplateDeviceModelName));
                table_entry->cltTemplateDeviceModelName_len =
                    table_entry->old_cltTemplateDeviceModelName_len;
                break;
            case COLUMN_CLTTEMPLATEROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        cltTemplateTable_removeEntry(table_data,
                                                     table_row);
                    }
                }
                break;
            case COLUMN_CLTTEMPLATESTORMFILTERENABLE:
                table_entry->cltTemplateStormFilterEnable =
                    table_entry->old_cltTemplateStormFilterEnable;
                table_entry->old_cltTemplateStormFilterEnable = 0;
                break;
            case COLUMN_CLTTEMPLATEMACLIMITATION:
                table_entry->cltTemplateMACLimitation =
                    table_entry->old_cltTemplateMACLimitation;
                table_entry->old_cltTemplateMACLimitation = 0;
                break;
            case COLUMN_CLTTEMPLATECABLEUPRATELIMITATION:
                table_entry->cltTemplateCableUpRateLimitation =
                    table_entry->old_cltTemplateCableUpRateLimitation;
                table_entry->old_cltTemplateCableUpRateLimitation = 0;
                break;
            case COLUMN_CLTTEMPLATECABLEDOWNRATELIMITATION:
                table_entry->cltTemplateCableDownRateLimitation =
                    table_entry->old_cltTemplateCableDownRateLimitation;
                table_entry->old_cltTemplateCableDownRateLimitation = 0;
                break;
            case COLUMN_CLTTEMPLATECABLEVLANMODE:
                table_entry->cltTemplateCableVLANMode =
                    table_entry->old_cltTemplateCableVLANMode;
                table_entry->old_cltTemplateCableVLANMode = 0;
                break;
            case COLUMN_CLTTEMPLATECABLEPVID:
                table_entry->cltTemplateCablePVID =
                    table_entry->old_cltTemplateCablePVID;
                table_entry->old_cltTemplateCablePVID = 0;
                break;
            }
        }*/
        break; 

    case MODE_SET_COMMIT:
		local_commit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int cltTemplateTable_load(netsnmp_cache *cache, void *vmagic)
{
	long			ret = -1, i;
	struct cltTemplateTable_entry entry;   

	ret = device_templates_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltTemplateTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltTemplateTable Group\n"));
	}
	
	HC_IPC_ASSERT(ret);	
	
	for (i = 0; i < device_templates_num; i ++){
		cltTemplateTable_setEntry(&entry, &device_templates[i]);
		cltTemplateTable_createEntry(i + 1, &entry);				
	}
	
	return ret; 
} 

void cltTemplateTable_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL((DBGID, "Free cltTemplateTable Group\n"));  
	
	cltTemplateTable_removeAllEntry();
}

ipc_service_template_t *cltTemplateTable_change_and_update(struct cltTemplateTable_entry *entry)
{
	static ipc_service_template_t tmpl_c, *tmpl;
	int tmpl_id = entry->cltTemplateIndex - 1;

	tmpl = &tmpl_c;

	//memset(tmpl, 0, sizeof(*tmpl));

	DBG_ASSERT((tmpl_id < device_templates_num), "Invalid tmplate ID");
	if (tmpl_id < device_templates_num){
		memcpy(tmpl, &device_templates[tmpl_id], sizeof(*tmpl));
	}else {
		snmp_log(LOG_ERR, "tmpl_id >= device_templates_num\n");
		return NULL;
	}

	safe_strncpy(tmpl->tmpl_name, entry->cltTemplateName, sizeof(tmpl->tmpl_name));
	safe_strncpy(tmpl->tmpl_desc, entry->cltTemplateDescription, sizeof(tmpl->tmpl_desc));
	tmpl->device_id = supported_devices_id_b0(entry->cltTemplateDeviceModelName);	

	DBG_ASSERT((tmpl->device_id < supported_devices_num), "Invalid device alias!");
	
	tmpl->mac_limit = entry->cltTemplateMACLimitation;

	tmpl->cable_rate_up = entry->cltTemplateCableUpRateLimitation;
	tmpl->cable_rate_dn = entry->cltTemplateCableDownRateLimitation;
	tmpl->lsw_cfg.cab_port.tagged = (entry->cltTemplateCableVLANMode == VLANTAG_tagged) ? 1 : 0;
	tmpl->lsw_cfg.cab_port.pvid = entry->cltTemplateCablePVID;
	tmpl->lsw_cfg.broadcast_storm = (entry->cltTemplateStormFilterEnable == TruthValue_true) ? 1 : 0;

	if (!memcmp(tmpl, &device_templates[tmpl_id], sizeof(*tmpl))){
		// no change
		return NULL;
	}
	return tmpl;
}


void cltTemplateTable_commit(unsigned int regNo, void *clientargs)
{

	/*
		We will handle row status first
		check every row status change.
		if any row status is destory, apply them and forget others changes
		else if any row status is to creat, and creat one for all and forget others
		else if any created row is to active , active the new one and forget others
		else if not row status change, apply row values change
	*/
	long ret;
    struct cltTemplateTable_entry *ptr;
	ipc_service_template_t templates[EOC_MAX_TMPL_NUMS], *tmpl;
	int do_num = 0;
	
	HC_VALID_ASSERT();

	memset(templates, 0, sizeof(templates));

// Delete if any
    for (ptr = cltTemplateTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if (ptr->cltTemplateRowStatus == RowStatus_destroy){
			templates[do_num].tmpl_id = ptr->cltTemplateIndex - 1;
			do_num ++;
		}
    }

	if (do_num){
		ret = ipc_del_template(templates, do_num);
		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to delete cltTemplateTable Group\n"));
		} else {
			DEBUGMSGTL((DBGID, "Deleted cltTemplateTable Group\n"));
		}
		HC_IPC_ASSERT1(ret);			
		return ;
	}

// creat  if any
    for (ptr = cltTemplateTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if ((ptr->cltTemplateRowStatus == RowStatus_createAndWait) 
			|| (ptr->cltTemplateRowStatus == RowStatus_createAndGo)){
			ret = ipc_new_template(1);
			if (HC_IPC_ERROR(ret)) {
				DEBUGMSGTL((DBGID, "Failed to new cltTemplateTable Group\n"));
			} else {
				DEBUGMSGTL((DBGID, "Newed cltTemplateTable Group\n"));
			}
			HC_IPC_ASSERT1(ret);			
			return ;
		}
    }
	
	// apply all changes
#if 0
	ret = device_templates_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltTemplateTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltTemplateTable Group\n"));
	}
	
	HC_IPC_ASSERT1(ret);	
#endif 	

    for (ptr = cltTemplateTable_commit_head; ptr != NULL; ptr = ptr->next) {
		tmpl = cltTemplateTable_change_and_update(ptr);
		if (tmpl){
			memcpy(&templates[do_num], tmpl, sizeof(*tmpl));
			do_num ++;
		}
    }

	cltTemplateTable_removeAllCommitEntry();


	if (do_num){
		ret = ipc_set_template(templates, do_num);
		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to commit cltTemplateTable Group\n"));
		} else {
			DEBUGMSGTL((DBGID, "Commited cltTemplateTable Group\n"));
		}		
		HC_IPC_ASSERT1(ret);
	} 
}



