/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltConfigRTC.h"

#include "ipc_interfaceTC.h"

#ifndef DBGID
#define DBGID  "hc:cltrtc"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltConfigRTC_commit, NULL)

typedef struct{
	long row_status; 
	long year;
	long month;
	long day;
	long hour;
	long minute;
	long second;
	long week;
}
cltConfigRTC_t;




static sys_time_t cltrtc;
static cltConfigRTC_t cltConfigRTC;


static oid	cltConfigRTC_oid[] = { HC_CLT_OBJ_OID, 2, 1, 7};


/** Initializes the cltConfigRTC module */
void
init_cltConfigRTC(void)
{
	netsnmp_handler_registration *reginfo;
	
	 /*
	  * register ourselves with the agent as a group of scalars...
	  */
		 
	 DEBUGMSGTL((DBGID, "Initializing\n"));
	
	 reginfo = netsnmp_create_handler_registration("cltConfigRTC", cltConfigRTC_handler,
			 cltConfigRTC_oid, OID_LENGTH(cltConfigRTC_oid), HANDLER_CAN_RWRITE);
	 
	 netsnmp_register_scalar_group(reginfo, CLTCONFIGRTCROWSTATUS, CLTCONFIGRTCWEEK);
	
	
	 netsnmp_inject_handler( reginfo,
			 netsnmp_get_cache_handler(  HC_CACHE_TIMEOUT,
					 cltConfigRTC_load, cltConfigRTC_free,
					 cltConfigRTC_oid, OID_LENGTH(cltConfigRTC_oid)));

}

int
handle_cltConfigRtcRowStatus(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.row_status
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.row_status)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
			break;
        }
		if (!validRtcRowStatus(vb_int(requests->requestvb))){
			ret = SNMP_ERR_WRONGVALUE;
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
		if (cltConfigRTC.row_status == RtcRowStatus_active){
			if ((vb_int(requests->requestvb) == RtcRowStatus_set)){
				local_commit();
			}			
		}         
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigRtcRowStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcYear(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.year
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.year)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
			break;
        }
        ret = netsnmp_check_vb_range(requests->requestvb, 2000, 2099);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
			break;
        }
		
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		cltConfigRTC.year = vb_int(requests->requestvb);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cltConfigRtcYear\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcMonth(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.month
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.month)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 1, 12);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		cltConfigRTC.month = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigRtcMonth\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcDay(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.day
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.day)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 1, 31);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			cltConfigRTC.day = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cltConfigRtcDay\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcHour(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.hour
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.hour)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 0, 23);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			cltConfigRTC.hour = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cltConfigRtcHour\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcMinute(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.minute
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.minute)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 0, 59);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			cltConfigRTC.minute= vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigRtcMinute\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcSecond(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.second
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.second)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 0, 59);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			cltConfigRTC.second = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltConfigRtcSecond\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltConfigRtcWeek(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&cltConfigRTC.week
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(cltConfigRTC.week)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}
		ret = netsnmp_check_vb_range(requests->requestvb, 1, 7);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
			break;
		}

        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
			cltConfigRTC.week = vb_int(requests->requestvb);

        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_cltConfigRtcWeek\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int cltConfigRTC_handler(netsnmp_mib_handler          *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info   *reqinfo,
             netsnmp_request_info         *requests)
{
    netsnmp_request_info  *request;
    netsnmp_variable_list *requestvb;
    oid      subid;

    /*
     * The cached data should already have been loaded by the
     *    cache handler, higher up the handler chain.
     * But just to be safe, check this and load it manually if necessary
     */

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltConfigRTC_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

	for (request=requests; request; request=request->next) {
		requestvb = request->requestvb;
		subid = requestvb->name[OID_LENGTH(cltConfigRTC_oid)];  /* XXX */
		DEBUGMSGTL(( DBGID, "oid: "));
		DEBUGMSGOID((DBGID, requestvb->name, requestvb->name_length));
		DEBUGMSG((DBGID, "\n"));


		switch(subid){
			case CLTCONFIGRTCROWSTATUS:
			handle_cltConfigRtcRowStatus(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCYEAR:
			handle_cltConfigRtcYear(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCMONTH:
			handle_cltConfigRtcMonth(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCDAY:
			handle_cltConfigRtcDay(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCHOUR:
			handle_cltConfigRtcHour(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCMINUTE:
			handle_cltConfigRtcMinute(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCSECOND:
			handle_cltConfigRtcSecond(handler, reginfo, reqinfo, request);
			break;
			case CLTCONFIGRTCWEEK:
			handle_cltConfigRtcWeek(handler, reginfo, reqinfo, request);
			break;

		}
	
	}

   return SNMP_ERR_NOERROR;
}



int cltConfigRTC_load(netsnmp_cache *cache, void *vmagic)
{
    long            ret = -1;
	struct tm tm;
	
	ret = ipc_get_sys_time(&cltrtc);
	
    if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		memset(&cltConfigRTC, 0, sizeof(cltConfigRTC));
		cltConfigRTC.row_status =RtcRowStatus_noneInService;
		
		DEBUGMSGTL((DBGID, "Failed to load cltConfigRTC Group\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded cltConfigRTC Group\n"));
    }

	HC_IPC_ASSERT(ret);

	gmtime_r(&cltrtc.time, &tm);

	cltConfigRTC.row_status = RtcRowStatus_active;	
	cltConfigRTC.year = tm.tm_year + 1900;
	cltConfigRTC.month = tm.tm_mon + 1;
	cltConfigRTC.day = tm.tm_mday;
	cltConfigRTC.hour = tm.tm_hour;
	cltConfigRTC.minute = tm.tm_min;
	cltConfigRTC.second = tm.tm_sec;
	cltConfigRTC.week = 0;
	
    return ret; 
}


void cltConfigRTC_free(netsnmp_cache *cache, void *magic)
{

}


void cltConfigRTC_commit(unsigned int regNo, void *clientargs)
{
	long ret;
	struct tm tm;

	HC_VALID_ASSERT();

	tm.tm_year = cltConfigRTC.year - 1900;
	tm.tm_mon = cltConfigRTC.month - 1;
	tm.tm_mday = cltConfigRTC.day;
	tm.tm_hour = cltConfigRTC.hour;
	tm.tm_min = cltConfigRTC.minute;
	tm.tm_sec = cltConfigRTC.second;

	cltrtc.time = mktime(&tm);
	cltrtc.ntp_en = 0;
	
	ret = ipc_set_sys_time(&cltrtc);
	if (HC_IPC_ERROR(ret)) {
		DEBUGMSGTL((DBGID, "Failed to commit cltConfigRTC Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Commited cltConfigRTC Group\n"));
	}

	HC_IPC_ASSERT1(ret);

}


