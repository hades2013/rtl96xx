/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltConfigInterfaceTable.h"


#include "ipc_interfaceTC.h"

#ifndef DBGID
#define DBGID  "hc:cltiftable"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltConfigInterfaceTable_commit, NULL)

static switch_interface_t cltiftable[MAX_CLT_ETH_PORTS];// defined in shared/cable.h
static switch_interface_status_t cltifstatus[MAX_CLT_ETH_PORTS];
static int cltiftable_num = 0;
static int cltifstatus_num = 0;
static char *show_if[] = {IFNAME_ETH0, IFNAME_ETH1, NULL};


/** Initializes the cltConfigInterfaceTable module */
void
init_cltConfigInterfaceTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_cltConfigInterfaceTable();
}

//# Determine the first/last column names

/** Initialize the cltConfigInterfaceTable table by defining its contents and how it's structured */
void
initialize_table_cltConfigInterfaceTable(void)
{
    static oid      cltConfigInterfaceTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 2, 2, 6 };
    size_t          cltConfigInterfaceTable_oid_len =
        OID_LENGTH(cltConfigInterfaceTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

	DEBUGMSGTL((DBGID, "Initializing\n"));

    reg =
        netsnmp_create_handler_registration("cltConfigInterfaceTable",
                                            cltConfigInterfaceTable_handler,
                                            cltConfigInterfaceTable_oid,
                                            cltConfigInterfaceTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: cltConfigIfIndex */
                                     0);
    table_info->min_column = COLUMN_CLTCONFIGIFINDEX;
    table_info->max_column = COLUMN_CLTCONFIGIFLINKDUPLEXMODE;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        cltConfigInterfaceTable_get_first_data_point;
    iinfo->get_next_data_point =
        cltConfigInterfaceTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);
	
    netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
			   		cltConfigInterfaceTable_load, cltConfigInterfaceTable_free,
					cltConfigInterfaceTable_oid, OID_LENGTH(cltConfigInterfaceTable_oid)));
    DEBUGMSGTL((DBGID,
                "initialize cltConfigInterfaceTable\n"));     

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct cltConfigInterfaceTable_entry {
    /*
     * Index values 
     */
    long            cltConfigIfIndex;

    /*
     * Column values 
     */
//    long            cltConfigIfIndex;
    long            cltConfigIfType;
    char            cltConfigIfName[HC_IFNAME_SIZE];
    size_t          cltConfigIfName_len;
    long            cltConfigIfAdminStatus;
    long            old_cltConfigIfAdminStatus;
    long            cltConfigIfDuplexMode;
    long            old_cltConfigIfDuplexMode;
    long            cltConfigIfSpeedMode;
    long            old_cltConfigIfSpeedMode;
    long            cltConfigIfFlowControl;
    long            old_cltConfigIfFlowControl;
    long            cltConfigIfPriority;
    long            old_cltConfigIfPriority;
    long            cltConfigIfIngressRateLimitation;
    long            old_cltConfigIfIngressRateLimitation;
    long            cltConfigIfEgressRateLimitation;
    long            old_cltConfigIfEgressRateLimitation;
    long            cltConfigIfPVID;
    long            old_cltConfigIfPVID;
    long            cltConfigIfLinkStatus;
    long            cltConfigIfLinkSpeedMode;
    long            cltConfigIfLinkDuplexMode;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct cltConfigInterfaceTable_entry *next;
};

struct cltConfigInterfaceTable_entry *cltConfigInterfaceTable_head;

/*
 * create a new row in the (unsorted) table 
 */
struct cltConfigInterfaceTable_entry *
cltConfigInterfaceTable_createEntry(long cltConfigIfIndex, 
					struct cltConfigInterfaceTable_entry *cltConfigInterfaceTable)
{
    struct cltConfigInterfaceTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltConfigInterfaceTable_entry);
    if (!entry)
        return NULL;

	memcpy(entry, cltConfigInterfaceTable, sizeof(*entry));

    entry->cltConfigIfIndex = cltConfigIfIndex;
    entry->next = cltConfigInterfaceTable_head;
    cltConfigInterfaceTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
cltConfigInterfaceTable_removeEntry(struct cltConfigInterfaceTable_entry
                                    *entry)
{
    struct cltConfigInterfaceTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = cltConfigInterfaceTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltConfigInterfaceTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


void cltConfigInterfaceTable_removeAllEntry(void )
{
    struct cltConfigInterfaceTable_entry *ptr, *pnext;

    for (ptr = cltConfigInterfaceTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigInterfaceTable_head = NULL;
}


struct cltConfigInterfaceTable_entry *
cltConfigInterfaceTable_getEntry(long cltConfigIfIndex)
{
	struct cltConfigInterfaceTable_entry *ptr;
	
    for (ptr = cltConfigInterfaceTable_head;ptr != NULL; ptr = ptr->next) {
		if (ptr->cltConfigIfIndex == cltConfigIfIndex){
			return ptr;
		}
    }	
	return NULL;
}


void cltConfigInterfaceTable_setEntry(
				struct cltConfigInterfaceTable_entry *entry, 
				switch_interface_t *cltif, switch_interface_status_t *cltifstatus)
{

	entry->cltConfigIfAdminStatus = cltif->enabled ? TruthValue_true : TruthValue_false;
	entry->cltConfigIfType = strstr(cltif->ifname, "eth") ? IFType_ethernet : IFType_cable;
	safe_strncpy(entry->cltConfigIfName, interface_fancy_name(cltif->ifname), sizeof(entry->cltConfigIfName));
	entry->cltConfigIfName_len = strlen(entry->cltConfigIfName);
	entry->cltConfigIfDuplexMode = cltif->duplex == ETH_DUPLEX_HALF ? IFDuplex_half : IFDuplex_full;

	if (cltif->speed == ETH_SPEED_1000){
		entry->cltConfigIfSpeedMode = IFSpeed_1000m;
	}else if (cltif->speed == ETH_SPEED_100){
		entry->cltConfigIfSpeedMode = IFSpeed_100m;
	}else {
		entry->cltConfigIfSpeedMode = IFSpeed_10m;
	}
	if (cltif->autoneg){
		entry->cltConfigIfDuplexMode = IFDuplex_auto;
		entry->cltConfigIfSpeedMode = IFSpeed_auto;
	}
	entry->cltConfigIfFlowControl = (cltif->flowctrl == ETH_FLOWCTRL_ON) ? TruthValue_true : TruthValue_false;
	entry->cltConfigIfPriority = cltif->priority; //TODO: 

	entry->cltConfigIfEgressRateLimitation = cltif->egress_limit;
	entry->cltConfigIfIngressRateLimitation = cltif->ingress_limit;
	entry->cltConfigIfPVID = cltif->pvid;
	entry->cltConfigIfLinkStatus = cltifstatus->link ? IFLink_on : IFLink_off;
	if (cltifstatus->speed == ETH_SPEED_1000){
		entry->cltConfigIfLinkSpeedMode = IFSpeed_1000m;
	}else if (cltifstatus->speed == ETH_SPEED_100){
		entry->cltConfigIfLinkSpeedMode = IFSpeed_100m;
	}else {
		entry->cltConfigIfLinkSpeedMode = IFSpeed_10m;
	}

    entry->cltConfigIfLinkDuplexMode = cltif->duplex == ETH_DUPLEX_HALF ? IFDuplex_half : IFDuplex_full;	
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
cltConfigInterfaceTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    *my_loop_context = cltConfigInterfaceTable_head;
    return cltConfigInterfaceTable_get_next_data_point(my_loop_context,
                                                       my_data_context,
                                                       put_index_data,
                                                       mydata);
}

netsnmp_variable_list *
cltConfigInterfaceTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    struct cltConfigInterfaceTable_entry *entry =
        (struct cltConfigInterfaceTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->cltConfigIfIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the cltConfigInterfaceTable table */
int
cltConfigInterfaceTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
	int ret;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct cltConfigInterfaceTable_entry *table_entry;

	netsnmp_variable_list *requestvb;	

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltConfigInterfaceTable_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));


    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigInterfaceTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);	

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGIFINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigIfIndex);
                break;
            case COLUMN_CLTCONFIGIFTYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigIfType);
                break;
            case COLUMN_CLTCONFIGIFNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltConfigIfName,
                                         table_entry->cltConfigIfName_len);
                break;
            case COLUMN_CLTCONFIGIFADMINSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfAdminStatus);
                break;
            case COLUMN_CLTCONFIGIFDUPLEXMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfDuplexMode);
                break;
            case COLUMN_CLTCONFIGIFSPEEDMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfSpeedMode);
                break;
            case COLUMN_CLTCONFIGIFFLOWCONTROL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfFlowControl);
                break;
            case COLUMN_CLTCONFIGIFPRIORITY:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfPriority);
                break;
            case COLUMN_CLTCONFIGIFINGRESSRATELIMITATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfIngressRateLimitation);
                break;
            case COLUMN_CLTCONFIGIFEGRESSRATELIMITATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfEgressRateLimitation);
                break;
            case COLUMN_CLTCONFIGIFPVID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigIfPVID);
                break;
            case COLUMN_CLTCONFIGIFLINKSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfLinkStatus);
                break;
            case COLUMN_CLTCONFIGIFLINKSPEEDMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfLinkSpeedMode);
                break;
            case COLUMN_CLTCONFIGIFLINKDUPLEXMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigIfLinkDuplexMode);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigInterfaceTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);				

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGIFADMINSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFDUPLEXMODE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFSPEEDMODE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFFLOWCONTROL:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFPRIORITY:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFINGRESSRATELIMITATION:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFEGRESSRATELIMITATION:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGIFPVID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigInterfaceTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);				

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGIFADMINSTATUS:
                table_entry->old_cltConfigIfAdminStatus =
                    table_entry->cltConfigIfAdminStatus;
                table_entry->cltConfigIfAdminStatus =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFDUPLEXMODE:
                table_entry->old_cltConfigIfDuplexMode =
                    table_entry->cltConfigIfDuplexMode;
                table_entry->cltConfigIfDuplexMode =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFSPEEDMODE:
                table_entry->old_cltConfigIfSpeedMode =
                    table_entry->cltConfigIfSpeedMode;
                table_entry->cltConfigIfSpeedMode =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFFLOWCONTROL:
                table_entry->old_cltConfigIfFlowControl =
                    table_entry->cltConfigIfFlowControl;
                table_entry->cltConfigIfFlowControl =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFPRIORITY:
                table_entry->old_cltConfigIfPriority =
                    table_entry->cltConfigIfPriority;
                table_entry->cltConfigIfPriority =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFINGRESSRATELIMITATION:
                table_entry->old_cltConfigIfIngressRateLimitation =
                    table_entry->cltConfigIfIngressRateLimitation;
                table_entry->cltConfigIfIngressRateLimitation =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFEGRESSRATELIMITATION:
                table_entry->old_cltConfigIfEgressRateLimitation =
                    table_entry->cltConfigIfEgressRateLimitation;
                table_entry->cltConfigIfEgressRateLimitation =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGIFPVID:
                table_entry->old_cltConfigIfPVID =
                    table_entry->cltConfigIfPVID;
                table_entry->cltConfigIfPVID =
                    *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigInterfaceTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);				

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGIFADMINSTATUS:
                table_entry->cltConfigIfAdminStatus =
                    table_entry->old_cltConfigIfAdminStatus;
                table_entry->old_cltConfigIfAdminStatus = 0;
                break;
            case COLUMN_CLTCONFIGIFDUPLEXMODE:
                table_entry->cltConfigIfDuplexMode =
                    table_entry->old_cltConfigIfDuplexMode;
                table_entry->old_cltConfigIfDuplexMode = 0;
                break;
            case COLUMN_CLTCONFIGIFSPEEDMODE:
                table_entry->cltConfigIfSpeedMode =
                    table_entry->old_cltConfigIfSpeedMode;
                table_entry->old_cltConfigIfSpeedMode = 0;
                break;
            case COLUMN_CLTCONFIGIFFLOWCONTROL:
                table_entry->cltConfigIfFlowControl =
                    table_entry->old_cltConfigIfFlowControl;
                table_entry->old_cltConfigIfFlowControl = 0;
                break;
            case COLUMN_CLTCONFIGIFPRIORITY:
                table_entry->cltConfigIfPriority =
                    table_entry->old_cltConfigIfPriority;
                table_entry->old_cltConfigIfPriority = 0;
                break;
            case COLUMN_CLTCONFIGIFINGRESSRATELIMITATION:
                table_entry->cltConfigIfIngressRateLimitation =
                    table_entry->old_cltConfigIfIngressRateLimitation;
                table_entry->old_cltConfigIfIngressRateLimitation = 0;
                break;
            case COLUMN_CLTCONFIGIFEGRESSRATELIMITATION:
                table_entry->cltConfigIfEgressRateLimitation =
                    table_entry->old_cltConfigIfEgressRateLimitation;
                table_entry->old_cltConfigIfEgressRateLimitation = 0;
                break;
            case COLUMN_CLTCONFIGIFPVID:
                table_entry->cltConfigIfPVID =
                    table_entry->old_cltConfigIfPVID;
                table_entry->old_cltConfigIfPVID = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
		local_commit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int cltConfigInterfaceTable_load(netsnmp_cache *cache, void *vmagic)
{ 
   long 		   ret = -1, i, t;
   struct cltConfigInterfaceTable_entry entry;   
   switch_interface_t *cltif;
   switch_interface_status_t *ifstatus;


   ret = ipc_get_interface(cltiftable, &cltiftable_num);

   if (!HC_IPC_ERROR(ret)){
	   ret = ipc_get_interface_status(cltifstatus, &cltifstatus_num);
   }
      
   if (HC_IPC_ERROR(ret)) {
	   CLR_VALID();
	   DEBUGMSGTL((DBGID, "Failed to load cltConfigInterfaceTable Group\n"));
   } else {
	   SET_VALID();
	   DEBUGMSGTL((DBGID, "Loaded cltConfigInterfaceTable Group\n"));
   }
   
   HC_IPC_ASSERT(ret);

   for (i = 0; show_if[i] != NULL; i ++){
   		cltif = NULL;
		ifstatus = NULL;
		for (t = 0; t < cltiftable_num; t ++){
			if (!strcmp(show_if[i], cltiftable[t].ifname)){
				cltif = &cltiftable[t];
			}
		}
		for (t = 0; t < cltifstatus_num; t ++){
			if (!strcmp(show_if[i], cltifstatus[t].ifname)){
				ifstatus = &cltifstatus[t];
			}
		}
		if ((cltif != NULL) && (ifstatus != NULL)){
			cltConfigInterfaceTable_setEntry(&entry, cltif, ifstatus);
			cltConfigInterfaceTable_createEntry(i + 1, &entry);			
		}	
   }
   return ret; 
} 

void cltConfigInterfaceTable_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL((DBGID, "Free cltConfigInterfaceTable Group\n"));  
	
	cltConfigInterfaceTable_removeAllEntry();
}


void cltConfigInterfaceTable_commit(unsigned int regNo, void *clientargs)
{
	long ret, i, j;
    struct cltConfigInterfaceTable_entry *ptr;
	switch_interface_t *cltif;
	switch_interface_status_t *ifstatus;
	switch_interface_t req[MAX_CLT_ETH_PORTS];
	int req_num = 0;

	HC_VALID_ASSERT();

	// update data from table

	for (i = 0; show_if[i] != NULL; i ++){
		 cltif = NULL;
		 ifstatus = NULL;
		 for (j = 0; j < cltiftable_num; j ++){
			 if (!strcmp(show_if[i], cltiftable[j].ifname)){
				 cltif = &cltiftable[i];
			 }
		 }
    	 ptr = cltConfigInterfaceTable_getEntry(i + 1);
		 if (ptr && cltif){
		 	 if ((ptr->cltConfigIfDuplexMode == IFDuplex_auto) 
			 	|| (ptr->cltConfigIfSpeedMode == IFSpeed_auto))	{
				cltif->autoneg = 1;
			 }else {
				cltif->autoneg = 0;
				if (ptr->cltConfigIfSpeedMode == IFSpeed_1000m){
					cltif->speed = ETH_SPEED_1000;
				}else if (ptr->cltConfigIfSpeedMode == IFSpeed_100m){
					cltif->speed = ETH_SPEED_100;
				}else {
					cltif->speed = ETH_SPEED_10;
				}
				cltif->duplex = (ptr->cltConfigIfDuplexMode == IFDuplex_full) ? ETH_DUPLEX_FULL : ETH_DUPLEX_HALF;
			 }
			 cltif->priority = ptr->cltConfigIfPriority;
			 cltif->flowctrl = (ptr->cltConfigIfFlowControl == TruthValue_true) ? 1 : 0;
			 cltif->egress_limit = ptr->cltConfigIfEgressRateLimitation;
			 cltif->ingress_limit = ptr->cltConfigIfIngressRateLimitation;
			 cltif->enabled = (ptr->cltConfigIfAdminStatus == TruthValue_true) ? 1 : 0;
			 memcpy(&req[req_num], cltif, sizeof(*cltif));
			 req_num ++;
		 } 
	}

	ret = ipc_set_interface(req, req_num);	

	if (HC_IPC_ERROR(ret)) {
		DEBUGMSGTL((DBGID, "Failed to commit cltConfigInterfaceTable Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Commited cltConfigInterfaceTable Group\n"));
	}

	HC_IPC_ASSERT1(ret);	

}


