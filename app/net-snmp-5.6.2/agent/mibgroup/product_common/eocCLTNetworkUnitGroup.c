/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "eocCLTNetworkUnitGroup.h"

#include "ipc_interfaceTC.h"

#ifndef DBGID
#define DBGID  "hc:cltcnu"
#endif 

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, eocCLTNetworkUnitGroup_commit, NULL)

static long anonymous_enable = 0;
static long topology_refresh = 0;

static ipc_clt_cable_param_t cltcabletable;


/** Initializes the eocCLTNetworkUnitGroup module */
void
init_eocCLTNetworkUnitGroup(void)
{
    netsnmp_handler_registration *reg;

    static oid      cltNetworkUnitAnonymousAllowed_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 2 };
    static oid      cltNetworkUnitAnonymousAccessTimeout_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 3 };
    static oid      cltNetworkTopologyRefresh_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 4 };
    static oid      cltNetworkUnitTopologyTotalNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 5 };
    static oid      cltNetworkUnitUserListTotalNumber_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 4, 3, 9 };

    DEBUGMSGTL((DBGID, "Initializing\n"));

    netsnmp_register_scalar(reg = netsnmp_create_handler_registration
                            ("cltNetworkUnitAnonymousAllowed",
                             handle_cltNetworkUnitAnonymousAllowed,
                             cltNetworkUnitAnonymousAllowed_oid,
                             OID_LENGTH
                             (cltNetworkUnitAnonymousAllowed_oid),
                             HANDLER_CAN_RWRITE));

	netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
			   		cltNetworkUnitAnonymousAllowed_load, cltNetworkUnitAnonymousAllowed_free,
					cltNetworkUnitAnonymousAllowed_oid, OID_LENGTH(cltNetworkUnitAnonymousAllowed_oid)));
		
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("cltNetworkUnitAnonymousAccessTimeout",
                             handle_cltNetworkUnitAnonymousAccessTimeout,
                             cltNetworkUnitAnonymousAccessTimeout_oid,
                             OID_LENGTH
                             (cltNetworkUnitAnonymousAccessTimeout_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("cltNetworkTopologyRefresh",
                             handle_cltNetworkTopologyRefresh,
                             cltNetworkTopologyRefresh_oid,
                             OID_LENGTH(cltNetworkTopologyRefresh_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("cltNetworkUnitTopologyTotalNumber",
                             handle_cltNetworkUnitTopologyTotalNumber,
                             cltNetworkUnitTopologyTotalNumber_oid,
                             OID_LENGTH
                             (cltNetworkUnitTopologyTotalNumber_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("cltNetworkUnitUserListTotalNumber",
                             handle_cltNetworkUnitUserListTotalNumber,
                             cltNetworkUnitUserListTotalNumber_oid,
                             OID_LENGTH
                             (cltNetworkUnitUserListTotalNumber_oid),
                             HANDLER_CAN_RONLY));
}

int
handle_cltNetworkUnitAnonymousAllowed(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */
	
	if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
		netsnmp_assert(!"cache == valid"); /* always false */
		cltNetworkUnitAnonymousAllowed_load( NULL, NULL ); /* XXX - check for failure */
	}
	
	DEBUGMSGTL((DBGID, "Handler - mode %s\n",
					se_find_label_in_slist("agent_mode", reqinfo->mode)));	


    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = anonymous_enable;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        anonymous_enable = (vb_int(requests->requestvb) == TruthValue_true) ? 1 : 0;
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
         local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltNetworkUnitAnonymousAllowed\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltNetworkUnitAnonymousAccessTimeout(netsnmp_mib_handler *handler,
                                            netsnmp_handler_registration
                                            *reginfo,
                                            netsnmp_agent_request_info
                                            *reqinfo,
                                            netsnmp_request_info *requests)
{
    int             ret;
	static int value = 0;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltNetworkUnitAnonymousAccessTimeout\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltNetworkTopologyRefresh(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    int             ret;
	static int value = CNURefresh_done;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		if(vb_int(requests->requestvb) == CNURefresh_scan){
			topology_refresh = 1;
		}
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        local_commit();
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltNetworkTopologyRefresh\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltNetworkUnitTopologyTotalNumber(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
	static int value = 0;
	int ret;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */
	ret = device_topology_update(0);
	if (HC_IPC_ERROR(ret)) {
		DEBUGMSGTL((DBGID, "Failed to update cltNetworkUnitTopologyTotalNumber Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Updated cltNetworkUnitTopologyTotalNumber Group\n"));
	}
	
	HC_IPC_ASSERT(ret);  

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = device_topology_num;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltNetworkUnitTopologyTotalNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cltNetworkUnitUserListTotalNumber(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
	static int value = 0;
	int ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */
	ret = device_userlists_update();
	if (HC_IPC_ERROR(ret)) {
		DEBUGMSGTL((DBGID, "Failed to update cltNetworkUnitUserListTotalNumber Group\n"));
	} else {
		DEBUGMSGTL((DBGID, "Updated cltNetworkUnitUserListTotalNumber Group\n"));
	}
	
	HC_IPC_ASSERT(ret);  

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		value = device_userlists_num;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 sizeof(value)/*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cltNetworkUnitUserListTotalNumber\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int cltNetworkUnitAnonymousAllowed_load(netsnmp_cache *cache, void *vmagic)
{
    long            ret = -1;
	
	ret = ipc_get_clt_cable_param(&cltcabletable);

    if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to load cltNetworkUnitAnonymousAllowed Group\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded cltNetworkUnitAnonymousAllowed Group\n"));
    }

	HC_IPC_ASSERT(ret);

	anonymous_enable = cltcabletable.clts[0].anonymous_control ? TruthValue_true : TruthValue_false;
	
    return ret; 
} 

void cltNetworkUnitAnonymousAllowed_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL((DBGID, "Free cltNetworkUnitAnonymousAllowed Group\n"));  

}

void eocCLTNetworkUnitGroup_commit(unsigned int regNo, void *clientargs)
{
	int ret = 0, i;
	if (topology_refresh){
		topology_refresh = 0;
		ret = device_topology_update(1);
		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to set cltNetworkTopologyRefresh\n"));
		} else {
			DEBUGMSGTL((DBGID, "Set cltNetworkTopologyRefresh\n"));
		} 
	}
	HC_IPC_ASSERT1(ret);
	HC_VALID_ASSERT();

	if (anonymous_enable != cltcabletable.clts[0].anonymous_control){
		for (i = 0; i < MAX_CLT_CHANNEL; i ++){
			cltcabletable.clts[i].anonymous_control = anonymous_enable;
		}
		ret = ipc_set_clt_cable_param(&cltcabletable);	

		if (HC_IPC_ERROR(ret)) {
			DEBUGMSGTL((DBGID, "Failed to commit eocCLTNetworkUnitGroup\n"));
		} else {
			DEBUGMSGTL((DBGID, "Commited eocCLTNetworkUnitGroup\n"));
		}
		HC_IPC_ASSERT1(ret);	
	}


}

