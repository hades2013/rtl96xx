/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "zgNetwrokInfo.h"
#include "../product_common/snmp_ipc_interfaceTC.h"
#include <lw_if_pub.h>
#include <signal.h>

/** Initializes the zgNetwrokInfo module */
#define SYS_STRING_LEN	256

unsigned long trap_ip = 0;
int ip_set_flag = 0;
int trap_analog_exit = 0;

void
send_deviceinfo_trap(unsigned long zgIpAddress, uint8_t 	*zgIpPhysicalAddress)
{
	/*
	 * In the notification, we have to assign our notification OID to
	 * the snmpTrapOID.0 object. Here is it's definition. 
	 */
	static char     version_descr[SYS_STRING_LEN] = "Triple Play Terminal";
	static char     sysName[SYS_STRING_LEN] = NETSNMP_SYS_NAME;
	char  ip[24];
	oid 			objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
	size_t			objid_snmptrap_len = OID_LENGTH(objid_snmptrap);//snmpTrapOID.0

	/*
	 * define the OID for the notification we're going to send
	 * NET-SNMP-EXAMPLES-MIB::netSnmpExampleHeartbeatNotification 
	 */
	oid 			enterpris_oid[] =
		{ 1, 3, 6, 1, 4, 1, 39596, 2, 2, 1};
	size_t			enterpris_oid_len = OID_LENGTH(enterpris_oid);
	
	oid 			ip_oid[] =
		{ 1, 3, 6, 1, 4, 1, 39596, 2, 1, 1, 0};
	size_t			ip_oid_len = OID_LENGTH(ip_oid);
   
	oid 			mac_oid[] =
		{ 1, 3, 6, 1, 4, 1, 39596, 2, 1, 5, 0};
	size_t			mac_oid_len = OID_LENGTH(mac_oid);

	oid 			sysDescr_oid[] =
		{ 1, 3, 6, 1, 2, 1, 1, 1, 0};
	size_t			sysDescr_oid_len = OID_LENGTH(sysDescr_oid);

	oid 			sysName_oid[] =
		{ 1, 3, 6, 1, 2, 1, 1, 5, 0};
	size_t			sysName_oid_len = OID_LENGTH(sysName_oid);
#if 0
	oid 	 hbeat_rate_oid[]	= { 1, 3, 6, 1, 6, 3, 1, 1, 4, 3, 0 };
	size_t	 hbeat_rate_oid_len = OID_LENGTH(hbeat_rate_oid);

	oid 			enterpris_oid[] =
		{ 1, 3, 6, 1, 4, 1, 39596,3, 3};
	size_t			enterpris_oid_len = OID_LENGTH(enterpris_oid);
#endif

	/*
	 * here is where we store the variables to be sent in the trap 
	 */
	netsnmp_variable_list *notification_vars = NULL;
   // const char *heartbeat_name = "A girl named Maria";

	DEBUGMSGTL(("netsnmp_udp", "defining the trap\n"));

	/*
	 * add in the trap definition object 
	 有多少数据要发送，就调用snmp_varlist_add_variable()多少次
	 */
	snmp_varlist_add_variable(&notification_vars,
							  /*
							   * the snmpTrapOID.0 variable 
							   */
							  objid_snmptrap, objid_snmptrap_len,
							  /*
							   * value type is an OID 
							   */
							  ASN_OBJECT_ID,
							  /*
							   * value contents is our notification OID 
							   */
							  (u_char *) enterpris_oid,
							  /*
							   * size in bytes = oid length * sizeof(oid) 
							   */
							  enterpris_oid_len * sizeof(oid));

	/*
	 * add in the additional objects defined as part of the trap
	 */
#if 0
	snmp_varlist_add_variable(&notification_vars,
							   hbeat_rate_oid, hbeat_rate_oid_len,
							   ASN_OBJECT_ID,
							  (u_char *)enterpris_oid,
							   enterpris_oid_len * sizeof(oid));
#endif
	snmp_varlist_add_variable(&notification_vars,
						   ip_oid, ip_oid_len,
						   ASN_IPADDRESS,
						   &zgIpAddress,
						   sizeof(zgIpAddress));
	snmp_varlist_add_variable(&notification_vars,
						   mac_oid, mac_oid_len,
						   ASN_OCTET_STR,
						   zgIpPhysicalAddress,
						   ETHER_ADDR_LEN * sizeof(uint8_t));
	snmp_varlist_add_variable(&notification_vars,
						   sysDescr_oid, sysDescr_oid_len,
						   ASN_OCTET_STR,
						   version_descr,
						   strlen(version_descr));
	
	cfg_getval(IF_ROOT_IFINDEX, CONFIG_SYSTEM_NAME, (void *)sysName, "", sizeof(sysName));
	snmp_varlist_add_variable(&notification_vars,
						   sysName_oid, sysName_oid_len,
						   ASN_OCTET_STR,
						   sysName,
						   strlen(sysName));
	send_v2trap(notification_vars);
	/*
	 * free the created notification variable list 
	 */
	DEBUGMSGTL(("netsnmp_udp", "cleaning up\n"));
	snmp_free_varbind(notification_vars);
}
void setip_handler(int sing)
{
	ipc_sys_network_ack_t *pack_send = NULL;
	sys_network_t info;
	ipc_sys_network_ack_t *pack = NULL; 
	ipc_network_t info_set;
	int ret = 0;
	if(1 == ip_set_flag)
	{
		pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
		if(pack && pack->hdr.status == IPC_STATUS_OK) 
		{
			memcpy(&info, &pack->network, sizeof(info));
		}
		if(pack) free(pack);

		memcpy(info_set.hostname, info.hostname, sizeof(info_set.hostname));
		info_set.ip_proto = info.ip_proto;
		memcpy(info_set.interface_state, info.interface_state, sizeof(info_set.interface_state));
		memcpy(&info_set.netif, &info.netif_static, sizeof(netif_param_t));
		info_set.action = ACTION_NONE;
		memcpy(&(info_set.netif.ip.s_addr),&trap_ip, sizeof(info_set.netif.ip.s_addr));
	    pack_send = ipc_sys_networking(ipc_fd, IPC_CONFIG_SET, IPC_APPLY_NOW , &info_set);
		if((!pack_send) || (pack_send->hdr.status != IPC_STATUS_OK)) 
		{		
			if(pack_send)
			{
				free(pack_send);
			}
			DEBUGMSGTL(("zgIpGateway","snmp set zgIp to master fail!\n")); 
			return SNMP_ERR_GENERR;
		}
		if(pack_send)
		{
			free(pack_send);
		}
		ret = ipc_system_request(IPC_SYS_NVRAM_COMMIT);
		if(IPC_STATUS_OK != ret)
	    {
	        printf("System running config saved to flash memory failed!");	   
		}
		ip_set_flag = 0;
	}
	return;
	
}

int check_ip(ipc_network_t *info_set)
{
	if (!valid_ip(info_set->netif.ip))
    {
        return SNMP_ERR_GENERR;
    }
    if (!valid_subnet_mask(info_set->netif.ip, info_set->netif.subnet))
    {
        return SNMP_ERR_GENERR;
    }
	return SNMP_ERR_NOERROR;
}

int check_gw(ipc_network_t *info_set)
{
	if (!valid_gateway(info_set->netif.ip, info_set->netif.subnet, info_set->netif.gateway))
    {
        return SNMP_ERR_GENERR; 
    }
	return SNMP_ERR_NOERROR;
}


void
init_zgNetwrokInfo(void)
{
    const oid       zgIpAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 39596, 2, 1, 1 };
    const oid       zgIpMask_oid[] = { 1, 3, 6, 1, 4, 1, 39596, 2, 1, 2 };
    const oid       zgIpGateway_oid[] =
        { 1, 3, 6, 1, 4, 1, 39596, 2, 1, 3 };
    const oid       zgIpPhysicalAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 39596, 2, 1, 5 };
    const oid       zgIpFind_oid[] = { 1, 3, 6, 1, 4, 1, 39596, 2, 2, 1 };

    DEBUGMSGTL(("zgNetwrokInfo", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("zgIpAddress", handle_zgIpAddress,
                             zgIpAddress_oid, OID_LENGTH(zgIpAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("zgIpMask", handle_zgIpMask, zgIpMask_oid,
                             OID_LENGTH(zgIpMask_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("zgIpGateway", handle_zgIpGateway,
                             zgIpGateway_oid, OID_LENGTH(zgIpGateway_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("zgIpPhysicalAddress",
                             handle_zgIpPhysicalAddress,
                             zgIpPhysicalAddress_oid,
                             OID_LENGTH(zgIpPhysicalAddress_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("zgIpFind", handle_zgIpFind, zgIpFind_oid,
                             OID_LENGTH(zgIpFind_oid),
                             HANDLER_CAN_RWRITE));
}

int
handle_zgIpAddress(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
    unsigned long zgIpAddress = 0;
	sys_network_t info;
	ipc_network_t info_set;
	ipc_sys_network_ack_t *pack = NULL;	
				
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &pack->network, sizeof(info));
		memcpy(&zgIpAddress, &(info.netif_static.ip.s_addr), sizeof(zgIpAddress)); 
	}
	if(pack) free(pack);

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                 (u_char *)&zgIpAddress
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(zgIpAddress)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        #if 1
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		#endif
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
         #if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
		memcpy(&info_set.netif, &info.netif_static, sizeof(netif_param_t));
        if (requests->requestvb->val.integer) 
        {
			if(*requests->requestvb->val.integer != zgIpAddress)
			{
				memcpy(&(info_set.netif.ip.s_addr), requests->requestvb->val.integer, sizeof(info_set.netif.ip.s_addr));
				struct itimerval it;

		        it.it_value.tv_sec = 1;
		        it.it_value.tv_usec = 0;
		        it.it_interval.tv_sec = 0;
		        it.it_interval.tv_usec = 0;
				setitimer(ITIMER_REAL, &it, NULL);

		        signal(SIGALRM, setip_handler);
				ip_set_flag = 1;
		        memcpy(&trap_ip, requests->requestvb->val.integer, sizeof(trap_ip));
				trap_analog_exit = 1;
			}
		}
		else {
            netsnmp_set_request_error(reqinfo, requests, /* some error */SNMP_ERR_BADVALUE
                                      );
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_zgIpAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_zgIpMask(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	unsigned long zgIpMask = 0;
	sys_network_t info;
	ipc_network_t info_set;
	ipc_sys_network_ack_t *pack = NULL;
	ipc_sys_network_ack_t *pack_send = NULL;
	int i = 0;
	int ipmask = 0;
	long mask_integer = 1;
	
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &pack->network, sizeof(info));
	}
	if(pack) free(pack);
	for(i = 0; i < 32; i++)
	{
		if(((info.netif_static.subnet.s_addr>>i)&0x01))
			break;
		else
			ipmask++;
	}
	
	zgIpMask = 32 - ipmask;
	
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&zgIpMask
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(zgIpMask)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        #if 1
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        #endif
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
         #if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        #if 1
		memcpy(info_set.hostname, info.hostname, sizeof(info_set.hostname));
		info_set.ip_proto = info.ip_proto;
		memcpy(info_set.interface_state, info.interface_state, sizeof(info_set.interface_state));
		memcpy(&info_set.netif, &info.netif_static, sizeof(netif_param_t));
		info_set.action = ACTION_NONE;
		if(*requests->requestvb->val.integer > 32)
		{
			DEBUGMSGTL(("zgIpMask","zgIpMask not more than 32 !\n")); 
					return SNMP_ERR_GENERR;
		}
        if (requests->requestvb->val.integer) 
        {
			if(*requests->requestvb->val.integer != zgIpMask)
			{
				mask_integer = 0xffffffff;
				mask_integer = (mask_integer << (32 - *requests->requestvb->val.integer));
				memcpy(&(info_set.netif.subnet.s_addr), &mask_integer, sizeof(info_set.netif.subnet.s_addr));
				pack_send = ipc_sys_networking(ipc_fd, IPC_CONFIG_SET, IPC_APPLY_NOW , &info_set);
				if((!pack_send) || (pack_send->hdr.status != IPC_STATUS_OK)) 
				{		
					if(pack_send)
					{
						free(pack_send);
					}
					DEBUGMSGTL(("zgIpMask","snmp set zgIpMask to master fail!\n")); 
					return SNMP_ERR_GENERR;
				}
				if(pack_send)
				{
					free(pack_send);
				}
				ret = ipc_system_request(IPC_SYS_NVRAM_COMMIT);
				if(IPC_STATUS_OK != ret)
			    {
			        printf("System running config saved to flash memory failed!");	   
				}
			}
		}
		else {
            netsnmp_set_request_error(reqinfo, requests, /* some error */SNMP_ERR_BADVALUE
                                      );
        }
		#endif
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_zgIpMask\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_zgIpGateway(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	unsigned long zgIpGateway = 0;
	sys_network_t info;
	ipc_network_t info_set;
	ipc_sys_network_ack_t *pack = NULL;
	ipc_sys_network_ack_t *pack_send = NULL;
	
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &pack->network, sizeof(info));
		memcpy(&zgIpGateway, &(info.netif_static.gateway.s_addr), sizeof(zgIpGateway)); 
	}
	if(pack) free(pack);

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                 (u_char *)&zgIpGateway
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(zgIpGateway)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        #if 1
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		#endif
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        #if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        #if 1
		memcpy(info_set.hostname, info.hostname, sizeof(info_set.hostname));
		info_set.ip_proto = info.ip_proto;
		memcpy(info_set.interface_state, info.interface_state, sizeof(info_set.interface_state));
		memcpy(&info_set.netif, &info.netif_static, sizeof(netif_param_t));
		info_set.action = ACTION_NONE;
        if (requests->requestvb->val.integer) 
        {
			if(*requests->requestvb->val.integer != zgIpGateway)
			{
				memcpy(&(info_set.netif.gateway.s_addr), requests->requestvb->val.integer, sizeof(info_set.netif.gateway.s_addr));
				pack_send = ipc_sys_networking(ipc_fd, IPC_CONFIG_SET, IPC_APPLY_NOW , &info_set);
				if((!pack_send) || (pack_send->hdr.status != IPC_STATUS_OK)) 
				{		
					if(pack_send)
					{
						free(pack_send);
					}
					DEBUGMSGTL(("zgIpGateway","snmp set zgIpGateway to master fail!\n")); 
					return SNMP_ERR_GENERR;
				}
				if(pack_send)
				{
					free(pack_send);
				}
				ret = ipc_system_request(IPC_SYS_NVRAM_COMMIT);
				if(IPC_STATUS_OK != ret)
			    {
			        printf("System running config saved to flash memory failed!");	   
				}
			}
		}
		else
		{
            netsnmp_set_request_error(reqinfo, requests, /* some error */SNMP_ERR_BADVALUE);
        }
		#endif
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_zgIpGateway\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_zgIpPhysicalAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	uint8_t 		zgIpPhysicalAddress[ETHER_ADDR_LEN];
	sys_network_t info;
	ipc_sys_network_ack_t *pack;
				
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &pack->network, sizeof(info));
		memcpy(&zgIpPhysicalAddress, &(info.mac), sizeof(zgIpPhysicalAddress)); 
	}
	if(pack) free(pack);

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)zgIpPhysicalAddress
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(zgIpPhysicalAddress)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_zgIpPhysicalAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_zgIpFind(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
    unsigned long zgIpFind = 0;
	unsigned long zgIpAddress = 0;
	uint8_t 	zgIpPhysicalAddress[ETHER_ADDR_LEN];
	sys_network_t info;
	ipc_sys_network_ack_t *pack;
				
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &pack->network, sizeof(info));
		zgIpFind = info.ip_proto; 
		memcpy(&zgIpAddress, &(info.netif_static.ip.s_addr), sizeof(zgIpAddress)); 
		memcpy(&zgIpPhysicalAddress, &(info.mac), sizeof(zgIpPhysicalAddress)); 
	}
	if(pack) free(pack);

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&zgIpFind
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(zgIpFind)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        #if 1
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
		#endif
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
         #if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */     
        send_deviceinfo_trap(zgIpAddress, zgIpPhysicalAddress);
         #if 0
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      );
        }
		#endif
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
         #if 0
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_zgIpFind\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
	
    return SNMP_ERR_NOERROR;
}
