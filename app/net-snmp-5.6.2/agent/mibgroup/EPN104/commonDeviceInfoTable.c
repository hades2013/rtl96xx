/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "commonDeviceInfoTable.h"
#include "../product_common/snmp_ipc_interfaceTC.h"

typedef struct {
    long            commonDeviceSlot;
    char            commonDevicesID[COMMONDEVICESID_MAX];
    size_t          commonDevicesID_len;
    char            commonDeviceVendor[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceVendor_len;
    char            commonDeviceModelNumber[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceModelNumber_len;
    char            commonDeviceSerialNumber[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceSerialNumber_len;
    char            commonDeviceVendorInfo[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceVendorInfo_len;
    char            commonDeviceStatus[COMMONDEVICESTATUS_MAX];
    size_t          commonDeviceStatus_len;
	uint8_t       	commonDeviceMACAddress[ETHER_ADDR_LEN];
	char            commonDeviceName[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceName_len;
    char            commonDeviceFW[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceFW_len;
}snmp_commonDeviceInfoTable_t;
snmp_commonDeviceInfoTable_t g_commonDeviceInfoTable;

typedef struct {
    long            analogAlarmState;
}snmp_analogstatus_t;
snmp_analogstatus_t g_analogstatus[ANALOGNODENUM];

int count = 0;
extern int trap_analog_exit;
/** Initializes the commonDeviceInfoTable module */
void
init_commonDeviceInfoTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_commonDeviceInfoTable();
}

//# Determine the first/last column names

/** Initialize the commonDeviceInfoTable table by defining its contents and how it's structured */
void
initialize_table_commonDeviceInfoTable(void)
{
    const oid       commonDeviceInfoTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 1, 3, 3, 2, 2 };
    const size_t    commonDeviceInfoTable_oid_len =
        OID_LENGTH(commonDeviceInfoTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;
	char commonDeviceStatus = 0x0;
	memset(&g_commonDeviceInfoTable, 0, sizeof(g_commonDeviceInfoTable));
    DEBUGMSGTL(("commonDeviceInfoTable:init",
                "initializing table commonDeviceInfoTable\n"));
	int i = 0;
	for(i = 0; i < ANALOGNODENUM ; i++)
	{
		g_analogstatus[i].analogAlarmState = 1;
	}

	g_commonDeviceInfoTable.commonDeviceSlot = 1;
	memset(g_commonDeviceInfoTable.commonDevicesID, 0, sizeof(g_commonDeviceInfoTable.commonDevicesID));
	g_commonDeviceInfoTable.commonDevicesID_len = sizeof(g_commonDeviceInfoTable.commonDevicesID);
	strncpy(g_commonDeviceInfoTable.commonDeviceVendor, " ", sizeof(g_commonDeviceInfoTable.commonDeviceVendor));
	g_commonDeviceInfoTable.commonDeviceVendor_len = sizeof(g_commonDeviceInfoTable.commonDeviceVendor);
	strncpy(g_commonDeviceInfoTable.commonDeviceModelNumber, " ", sizeof(g_commonDeviceInfoTable.commonDeviceModelNumber));
	g_commonDeviceInfoTable.commonDeviceModelNumber_len = sizeof(g_commonDeviceInfoTable.commonDeviceModelNumber);
	memset(g_commonDeviceInfoTable.commonDeviceSerialNumber, 0, sizeof(g_commonDeviceInfoTable.commonDeviceSerialNumber));
	g_commonDeviceInfoTable.commonDeviceSerialNumber_len = sizeof(g_commonDeviceInfoTable.commonDeviceSerialNumber);
	strncpy(g_commonDeviceInfoTable.commonDeviceVendorInfo, " ", sizeof(g_commonDeviceInfoTable.commonDeviceVendorInfo));
	g_commonDeviceInfoTable.commonDeviceVendorInfo_len = sizeof(g_commonDeviceInfoTable.commonDeviceVendorInfo);
	memcpy(g_commonDeviceInfoTable.commonDeviceStatus, &commonDeviceStatus, sizeof(g_commonDeviceInfoTable.commonDeviceStatus));
	g_commonDeviceInfoTable.commonDeviceStatus_len = sizeof(g_commonDeviceInfoTable.commonDeviceStatus);
	memset(g_commonDeviceInfoTable.commonDeviceMACAddress, 0, sizeof(g_commonDeviceInfoTable.commonDeviceMACAddress)); 
	strncpy(g_commonDeviceInfoTable.commonDeviceName, "Triple Play Terminal", sizeof(g_commonDeviceInfoTable.commonDeviceName));
	g_commonDeviceInfoTable.commonDeviceName_len = sizeof(g_commonDeviceInfoTable.commonDeviceName);
	memset(g_commonDeviceInfoTable.commonDeviceFW, 0, sizeof(g_commonDeviceInfoTable.commonDeviceFW));
	g_commonDeviceInfoTable.commonDeviceFW_len = sizeof(g_commonDeviceInfoTable.commonDeviceFW);
    reg =
        netsnmp_create_handler_registration("commonDeviceInfoTable",
                                            commonDeviceInfoTable_handler,
                                            commonDeviceInfoTable_oid,
                                            commonDeviceInfoTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: commonDeviceSlot */
                                     0);
    table_info->min_column = COLUMN_COMMONDEVICESLOT;
    table_info->max_column = COLUMN_COMMONDEVICEFW;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        commonDeviceInfoTable_get_first_data_point;
    iinfo->get_next_data_point = commonDeviceInfoTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);
	netsnmp_inject_handler( reg,
					netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
							commonDeviceInfoTable_load, commonDeviceInfoTable_free,
							commonDeviceInfoTable_oid, OID_LENGTH(commonDeviceInfoTable_oid)));
			DEBUGMSGTL(("commonDeviceInfoTable",
						"initialize commonDeviceInfoTable\n")); 

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct commonDeviceInfoTable_entry {
    /*
     * Index values 
     */
    long            commonDeviceSlot;

    /*
     * Column values 
     */
    //long            commonDeviceSlot;
    char            commonDevicesID[COMMONDEVICESID_MAX];
    size_t          commonDevicesID_len;
    char            commonDeviceVendor[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceVendor_len;
    char            commonDeviceModelNumber[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceModelNumber_len;
    char            commonDeviceSerialNumber[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceSerialNumber_len;
    char            commonDeviceVendorInfo[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceVendorInfo_len;
    char            commonDeviceStatus[COMMONDEVICESTATUS_MAX];
    size_t          commonDeviceStatus_len;
	#if 0
    long            commonDeviceReset;
    long            old_commonDeviceReset;
    long            commonDeviceAlarmDetectionControl;
    long            old_commonDeviceAlarmDetectionControl;
	#endif
    uint8_t       	commonDeviceMACAddress[ETHER_ADDR_LEN];
	#if 0
    long            commonDeviceTamperStatus;
    long            commonDeviceInternalTemperature;
    long            commonDeviceResetCause;
    long            commonDeviceCraftStatus;
    oid             commonDevicesOID[COMMONDEVICES_MAX_DIS];
    size_t          commonDevicesOID_len;
    u_long          commonDeviceAcct;
	#endif
    char            commonDeviceName[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceName_len;
	#if 0
    char            commonDeviceMFD[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceMFD_len;
	#endif
    char            commonDeviceFW[COMMONDEVICES_MAX_DIS];
    size_t          commonDeviceFW_len;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct commonDeviceInfoTable_entry *next;
};

struct commonDeviceInfoTable_entry *commonDeviceInfoTable_head;

/*
 * create a new row in the (unsorted) table 
 */
struct commonDeviceInfoTable_entry *
commonDeviceInfoTable_createEntry(struct commonDeviceInfoTable_entry *commonDeviceInfoTable)
{
    struct commonDeviceInfoTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct commonDeviceInfoTable_entry);
    if (!entry)
        return NULL;

    //entry->commonDeviceSlot = commonDeviceSlot;
	memcpy(entry, commonDeviceInfoTable, sizeof(*entry));
    entry->next = commonDeviceInfoTable_head;
    commonDeviceInfoTable_head = entry;
    return entry;
}

void commonDeviceInfoTable_setEntry(
				struct commonDeviceInfoTable_entry *entry, 
				snmp_commonDeviceInfoTable_t *pinfo
				)
{

	memset(entry, 0, sizeof(*entry));
	
	entry->commonDeviceSlot = pinfo->commonDeviceSlot;
	memcpy(entry->commonDevicesID, pinfo->commonDevicesID, sizeof(entry->commonDevicesID));
	entry->commonDevicesID_len = pinfo->commonDevicesID_len;
	strncpy(entry->commonDeviceVendor, pinfo->commonDeviceVendor, sizeof(entry->commonDeviceVendor));
	entry->commonDeviceVendor_len = pinfo->commonDeviceVendor_len;
	strncpy(entry->commonDeviceModelNumber, pinfo->commonDeviceModelNumber, sizeof(entry->commonDeviceModelNumber));
	entry->commonDeviceModelNumber_len = pinfo->commonDeviceModelNumber_len;
	memcpy(entry->commonDeviceSerialNumber, pinfo->commonDeviceSerialNumber, sizeof(entry->commonDeviceSerialNumber));
	entry->commonDeviceSerialNumber_len = pinfo->commonDeviceSerialNumber_len;
	strncpy(entry->commonDeviceVendorInfo, pinfo->commonDeviceVendorInfo, sizeof(entry->commonDeviceVendorInfo));
	entry->commonDeviceVendorInfo_len = pinfo->commonDeviceVendorInfo_len;
	memcpy(entry->commonDeviceStatus, pinfo->commonDeviceStatus, sizeof(entry->commonDeviceStatus));
	entry->commonDeviceStatus_len = pinfo->commonDeviceStatus_len;
	memcpy(entry->commonDeviceMACAddress, pinfo->commonDeviceMACAddress, sizeof(entry->commonDeviceMACAddress)); 
	strncpy(entry->commonDeviceName, pinfo->commonDeviceName, sizeof(entry->commonDeviceName));
	entry->commonDeviceName_len = pinfo->commonDeviceName_len;
	strncpy(entry->commonDeviceFW, pinfo->commonDeviceFW, sizeof(entry->commonDeviceFW));
	entry->commonDeviceFW_len = pinfo->commonDeviceFW_len;
}

/*
 * remove a row from the table 
 */
void
commonDeviceInfoTable_removeEntry(struct commonDeviceInfoTable_entry
                                  *entry)
{
    struct commonDeviceInfoTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = commonDeviceInfoTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        commonDeviceInfoTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void commonDeviceInfoTable_removeAllEntry(void )
{
    struct commonDeviceInfoTable_entry *ptr, *pnext;

    for (ptr = commonDeviceInfoTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	commonDeviceInfoTable_head = NULL;
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
commonDeviceInfoTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    *my_loop_context = commonDeviceInfoTable_head;
    return commonDeviceInfoTable_get_next_data_point(my_loop_context,
                                                     my_data_context,
                                                     put_index_data,
                                                     mydata);
}

netsnmp_variable_list *
commonDeviceInfoTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    struct commonDeviceInfoTable_entry *entry =
        (struct commonDeviceInfoTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->commonDeviceSlot);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the commonDeviceInfoTable table */
int
commonDeviceInfoTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
	int ret = 0;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct commonDeviceInfoTable_entry *table_entry;

    DEBUGMSGTL(("commonDeviceInfoTable:handler",
                "Processing request (%d)\n", reqinfo->mode));
    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct commonDeviceInfoTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_COMMONDEVICESLOT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->commonDeviceSlot);
                break;
            case COLUMN_COMMONDEVICESID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDevicesID,
                                         sizeof(table_entry->commonDevicesID));
                break;
            case COLUMN_COMMONDEVICEVENDOR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceVendor,
                                         strlen(table_entry->commonDeviceVendor));
                break;
            case COLUMN_COMMONDEVICEMODELNUMBER:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceModelNumber,
                                         strlen(table_entry->commonDeviceModelNumber));
                break;
            case COLUMN_COMMONDEVICESERIALNUMBER:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceSerialNumber,
                                         strlen(table_entry->commonDeviceSerialNumber));
                break;
            case COLUMN_COMMONDEVICEVENDORINFO:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceVendorInfo,
                                         strlen(table_entry->commonDeviceVendorInfo));
                break;
            case COLUMN_COMMONDEVICESTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceStatus,
                                         table_entry->commonDeviceStatus_len);
                break;
			#if 0
            case COLUMN_COMMONDEVICERESET:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->commonDeviceReset);
                break;			
            case COLUMN_COMMONDEVICEALARMDETECTIONCONTROL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           commonDeviceAlarmDetectionControl);
                break;
			#endif
            case COLUMN_COMMONDEVICEMACADDRESS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb,
                                           ASN_OCTET_STR,
                                           table_entry->commonDeviceMACAddress,
                                           sizeof(table_entry->commonDeviceMACAddress));
                break;
			#if 0
            case COLUMN_COMMONDEVICETAMPERSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           commonDeviceTamperStatus);
                break;
            case COLUMN_COMMONDEVICEINTERNALTEMPERATURE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           commonDeviceInternalTemperature);
                break;
            case COLUMN_COMMONDEVICERESETCAUSE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           commonDeviceResetCause);
                break;
            case COLUMN_COMMONDEVICECRAFTSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           commonDeviceCraftStatus);
                break;
            case COLUMN_COMMONDEVICESOID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         commonDevicesOID,
                                         table_entry->
                                         commonDevicesOID_len);
                break;
            case COLUMN_COMMONDEVICEACCT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_COUNTER,
                                           table_entry->commonDeviceAcct);
                break;
			#endif
            case COLUMN_COMMONDEVICENAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceName,
                                         strlen(table_entry->commonDeviceName));
                break;
			#if 0
            case COLUMN_COMMONDEVICEMFD:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         commonDeviceMFD,
                                         table_entry->commonDeviceMFD_len);
                break;
			#endif
            case COLUMN_COMMONDEVICEFW:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->commonDeviceFW,
                                         strlen(table_entry->commonDeviceFW));
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    #if 0
    case MODE_SET_RESERVE1:
	#if 0
        for (request = requests; request; request = request->next) {
            table_entry = (struct commonDeviceInfoTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_COMMONDEVICERESET:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMONDEVICEALARMDETECTIONCONTROL:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
	#endif
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	#if 0
        for (request = requests; request; request = request->next) {
            table_entry = (struct commonDeviceInfoTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_COMMONDEVICERESET:
                table_entry->old_commonDeviceReset =
                    table_entry->commonDeviceReset;
                table_entry->commonDeviceReset =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_COMMONDEVICEALARMDETECTIONCONTROL:
                table_entry->old_commonDeviceAlarmDetectionControl =
                    table_entry->commonDeviceAlarmDetectionControl;
                table_entry->commonDeviceAlarmDetectionControl =
                    *request->requestvb->val.integer;
                break;
            }
        }
	#endif
        break;

    case MODE_SET_UNDO:
	#if 0
        for (request = requests; request; request = request->next) {
            table_entry = (struct commonDeviceInfoTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_COMMONDEVICERESET:
                table_entry->commonDeviceReset =
                    table_entry->old_commonDeviceReset;
                table_entry->old_commonDeviceReset = 0;
                break;
            case COLUMN_COMMONDEVICEALARMDETECTIONCONTROL:
                table_entry->commonDeviceAlarmDetectionControl =
                    table_entry->old_commonDeviceAlarmDetectionControl;
                table_entry->old_commonDeviceAlarmDetectionControl = 0;
                break;
            }
        }
	#endif
        break;

    case MODE_SET_COMMIT:
        break;
	#endif
    }
    return SNMP_ERR_NOERROR;
}

int commonDeviceInfoTable_load(netsnmp_cache *cache, void *vmagic)
{
	int ret = 0;
	int i = 0;
	int analog_node_num = 3;
	struct commonDeviceInfoTable_entry entry;

	snmp_commonDeviceInfoTable_t *info = NULL;
	version_t sys_version = {version_string, version_count, version_date};

	/* Free All */
	commonDeviceInfoTable_removeAllEntry();
	info = &g_commonDeviceInfoTable;
	
    GetSN(info->commonDeviceSerialNumber,sizeof(info->commonDeviceSerialNumber));
	strncpy(info->commonDeviceFW,  sys_version.toString(), sizeof(info->commonDeviceFW));
	uint8_t 		zgIpPhysicalAddress[ETHER_ADDR_LEN];
	
	sys_network_t info_mac;
	ipc_sys_network_ack_t *pack;
	AnalogProperty_t pinfo;
	ipc_analogPropertyTable_ack_t *pack_analog = NULL;
	
	pack = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info_mac, &pack->network, sizeof(info_mac));
		memcpy(info->commonDeviceMACAddress, &(info_mac.mac.octet), sizeof(info->commonDeviceMACAddress)); 
		memcpy(info->commonDeviceModelNumber, "ZBL5932C",sizeof(info->commonDeviceModelNumber)); 
	}
	if(pack) free(pack);
	for(i = 0; i < ETHER_ADDR_LEN*2; i = i+2)
	{
		//info->commonDevicesID[i] = info_mac.mac.octet[i];
		info->commonDevicesID[i] = hex2ascii(info_mac.mac.octet[i/2]>>4);
		info->commonDevicesID[i+1] = hex2ascii(info_mac.mac.octet[i/2]);
	}

	pack_analog = ipc_analogPropertyTable(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack_analog && pack_analog->hdr.status == IPC_STATUS_OK) 
	{		
		memcpy(&pinfo , &pack_analog->AnalogProperty, sizeof(AnalogProperty_t));

		if(pack_analog)
		{
			free(pack_analog);
		}
	}
	else
	{	
		if(pack_analog)
		{
			free(pack_analog);
		}		
	}
	info->commonDeviceStatus[0] = info->commonDeviceStatus[0]&0x00;
	
	for(i = 0; i < analog_node_num; i++)
	{
		if((2 == pinfo.AnalogAlarmPropertyTable[i].analogAlarmState) || (5 == pinfo.AnalogAlarmPropertyTable[i].analogAlarmState))
		{
			info->commonDeviceStatus[0] = info->commonDeviceStatus[0] | 0x08;
		}
		if((3 == pinfo.AnalogAlarmPropertyTable[i].analogAlarmState) || (4 == pinfo.AnalogAlarmPropertyTable[i].analogAlarmState))
		{
			info->commonDeviceStatus[0] = info->commonDeviceStatus[0] | 0x10;
		}
	}
	for(i = 0; i < analog_node_num; i++)
	{
	/* count == 1是为了防止一开始产生告警信息，
	网管在注册时第一次收不到trap信息
	第二次轮询再发一次trap告警信息
	*/
		if((1 == count) && (g_analogstatus[i].analogAlarmState != pinfo.AnalogAlarmPropertyTable[i].analogAlarmState))
		{
			send_alarmtrap(i,&pinfo);
			g_analogstatus[i].analogAlarmState = pinfo.AnalogAlarmPropertyTable[i].analogAlarmState;			
		}		
	}
	/*设备IP改变，若告警存在，用新的IP发trap。*/
	if(1 == trap_analog_exit)
	{
		for(i = 0; i < analog_node_num; i++)
		{
			if(1 != pinfo.AnalogAlarmPropertyTable[i].analogAlarmState)
			{
				send_alarmtrap(i,&pinfo);
			}
		}
		trap_analog_exit = 0;
	}
	commonDeviceInfoTable_setEntry(&entry, info);	
	commonDeviceInfoTable_createEntry(&entry);	

safe_exit:
	
	HC_IPC_ASSERT(ret);
	
	count++;
	if(count > 2)
		count = 2;
    return ret; 
} 


void commonDeviceInfoTable_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL(("commonDeviceInfoTable", "Free commonDeviceInfoTable Group\n"));  
}

