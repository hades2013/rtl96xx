/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "miscIdent.h"

#include "../product_common/snmp_ipc_interface.h"
#define DBGTOKEN "miscIdent"

int handle_comDeviceVoltage12V(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests);
int handle_comDeviceVersionInfo(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests);

int handle_comDeviceRFAttenuation(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests);




/** Initializes the miscIdent module */
void
init_miscIdent(void)
{
    /*
    const oid       commonInternalTemperature_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID,1, 3, 1, 13 };*/
#ifdef CONFIG_CATVCOM
    const oid       comDeviceVoltage12V_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 1 };
    const oid       comDeviceRFAttenuation_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 2 };
    const oid       comDeviceVersionInfo_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 3 };
    #endif
    const oid       SaveConfig_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 4 };
    const oid       HardVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 5 };
    const oid       sw_version_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 6 };       
    const oid       buildtime_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 7 };
    const oid       sysmac_oid[] =
        { 1, 3, 6, 1, 4, 1, NETSNMP_ENTERPRISE_OID, 1, 15, 8 };


    DEBUGMSGTL(("miscIdent", "Initializing\n"));
    /*
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("commonInternalTemperature",
                             handle_commonInternalTemperature,
                             commonInternalTemperature_oid,
                             OID_LENGTH(commonInternalTemperature_oid),
                             HANDLER_CAN_RONLY));
    */
    #ifdef CONFIG_CATVCOM
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("comDeviceVoltage12V",
                             handle_comDeviceVoltage12V,
                             comDeviceVoltage12V_oid,
                             OID_LENGTH(comDeviceVoltage12V_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("comDeviceRFAttenuation",
                             handle_comDeviceRFAttenuation,
                             comDeviceRFAttenuation_oid,
                             OID_LENGTH(comDeviceRFAttenuation_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("comDeviceVersionInfo",
                             handle_comDeviceVersionInfo,
                             comDeviceVersionInfo_oid,
                             OID_LENGTH(comDeviceVersionInfo_oid),
                             HANDLER_CAN_RONLY));
    #endif
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("SaveConfig",
                             handle_SaveConfig,
                             SaveConfig_oid,
                             OID_LENGTH(SaveConfig_oid),
                             HANDLER_CAN_RWRITE));


    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("HardVersion",
                             handle_hw_version,
                             HardVersion_oid,
                             OID_LENGTH(HardVersion_oid),
                             HANDLER_CAN_RONLY));          
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sw_version",
                             handle_sw_version,
                             sw_version_oid,
                             OID_LENGTH(sw_version_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("buildtime",
                             handle_buildtime,
                             buildtime_oid,
                             OID_LENGTH(buildtime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysmac",
                             handle_sysmac,
                             sysmac_oid,
                             OID_LENGTH(sysmac_oid),
                             HANDLER_CAN_RONLY));

}

#if 0
int
handle_commonInternalTemperature(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{	
	char val[MAX_CATVINFO_SIZE] = {0};

	#ifdef CONFIG_CATVCOM
	sys_snmp_t *info = NULL;
	ipc_sys_snmp_ack_t *pack = NULL;
	pack = ipc_sys_snmp(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{		
		info = &pack->snmp;
		strncpy(val, info->snmp_catvinfo.temper, sizeof(val));
		if(pack)
		{
		free(pack);
		}
	}
	else
	{	
		if(pack)
		{
		free(pack);
		}
		snmp_log(LOG_ERR, "snmp get commonInternalTemperature from master fail!\n");
		return SNMP_ERR_GENERR;
	}
	#else
	strncpy(val, ERROR_DISPLAY, sizeof(val));
	#endif
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
       snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;
    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in commonInternalTemperature\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
handle_comDeviceVoltage12V(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
	char val[MAX_CATVINFO_SIZE] = {0};
	long            dorDCPowerVoltage;
#ifdef CONFIG_CATVCOM
	catvinfo_t *info = NULL;
	ipc_catvinfo_ack_t *pack = NULL;
	pack = ipc_catv_config(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{		
		info = &pack->catvinfo;
		#if defined(CONFIG_ZBL_SNMP)
		dorDCPowerVoltage = info->power_12v;
		#else
		strncpy(val, info->power_12v, sizeof(val));
		#endif
		if(pack)
		{
			free(pack);
		}
	}
	else
	{	
		if(pack)
		{
			free(pack);
		}
		snmp_log(LOG_ERR, "snmp get comDeviceVoltage12V from master fail!\n");
		return SNMP_ERR_GENERR;
	}
#else
	strncpy(val, ERROR_DISPLAY, sizeof(val));
#endif
	/*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		#if defined(CONFIG_ZBL_SNMP)
		snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, dorDCPowerVoltage);
		#else
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
		#endif
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVoltage12V\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_comDeviceRFAttenuation(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
	unsigned long output_level_atten = 0;
	int  ret = 0;

#ifdef CONFIG_CATVCOM
	unsigned short dev_status_update = 0;
	catvinfo_t *info = NULL;
	catvinfo_t info_send;
	ipc_catvinfo_ack_t *pack = NULL;
	ipc_catvinfo_ack_t *pack_tmp = NULL;

	pack_tmp = ipc_catv_config(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack_tmp && pack_tmp->hdr.status == IPC_STATUS_OK) 
	{		
		info = &pack_tmp->catvinfo;
		output_level_atten = info->output_level_atten;
		dev_status_update = info->dev_status_update;
		if(pack_tmp)
		{
			free(pack_tmp);
		}
	}
	else
	{	if(pack_tmp)
		{		
			free(pack_tmp);
		}
		snmp_log(LOG_ERR, "snmp get comDeviceRFAttenuation from master fail!\n");
		return SNMP_ERR_GENERR;
	}
#endif
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&output_level_atten, sizeof(&output_level_atten));
        break;


    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
    case MODE_SET_RESERVE2:
		#if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;
    case MODE_SET_ACTION:
		DEBUGMSGTL((DBGTOKEN,"snmp: get output_level_atten=%lu, set output_level_atten=%lu\n",output_level_atten, *requests->requestvb->val.integer)); 
		if((*requests->requestvb->val.integer == 0) || (*requests->requestvb->val.integer == 2) || (*requests->requestvb->val.integer == 4) ||
		   (*requests->requestvb->val.integer == 6))
		{	
		#ifdef CONFIG_CATVCOM
			if(*requests->requestvb->val.integer != output_level_atten)
			{
				memset(&info_send, 0 , sizeof(info_send));	
				info_send.output_level_atten = *requests->requestvb->val.integer;
				info_send.dev_status_update = dev_status_update;
				info_send.module_mask |= DEV_STATUS;
				pack = ipc_catv_config(ipc_fd, IPC_CONFIG_SET, IPC_APPLY_NOW , &info_send);
				if((!pack) || (pack->hdr.status != IPC_STATUS_OK)) 
				{		
					if(pack)
					{
						free(pack);
					}
					DEBUGMSGTL((DBGTOKEN,"snmp set comDeviceRFAttenuation to master fail!\n")); 
					return SNMP_ERR_GENERR;
				}
				if(pack)
				{
					free(pack);
				}				
			}
		#endif
		}
		else
		{
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
		}
        break;
    case MODE_SET_COMMIT:
		#if 0
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;
    case MODE_SET_UNDO:

		 #if 0
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;
     case MODE_SET_FREE:

        break;
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceRFAttenuation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_comDeviceVersionInfo(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char val[MAX_CATVINFO_SIZE] = {0};
	
#ifdef CONFIG_CATVCOM
	catvinfo_t *info = NULL;
	ipc_catvinfo_ack_t *pack = NULL;
	pack = ipc_catv_config(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{		
		info = &pack->catvinfo;
		strncpy(val, info->soft_version, sizeof(val));
		if(pack)
		{
			free(pack);
		}
	}
	else
	{	
		if(pack)
		{
			free(pack);
		}
		snmp_log(LOG_ERR, "snmp get comDeviceVersionInfo from master fail!\n");
		return SNMP_ERR_GENERR;
	}
#else
	strncpy(val, ERROR_DISPLAY, sizeof(val));
#endif
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		/*if (catv_op_get_version(&version) == CATV_OP_OK){
			ulong_ret = (version.ven_id << 24) + (version.dev_id << 16)
				+ (version.sw_version << 8) + version.hw_version;
		}*/	
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVersionInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_SaveConfig(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
	ipc_system_ack_t *pack;
	int nvram_changes = 0;
	int ret;
	unsigned long  output_change = 0;
	
	pack = ipc_system_req(ipc_fd, IPC_SYS_STATUS, 0);
	if (pack && (pack->hdr.status == IPC_STATUS_OK)){
		
		if (pack->status & IPC_SYS_STATUS_NVRAM_CHANGE){
			nvram_changes = 1;
		}
	}
	if (pack) free(pack);
    


	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        if(nvram_changes==1)
        {           
            output_change=2;
        }
        else
        {
            output_change=0;           
        }
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&output_change, sizeof(&output_change));
        break;


    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
    case MODE_SET_RESERVE2:
		#if 0
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
		#endif
        break;
    case MODE_SET_ACTION:		
		//DEBUGMSGTL(("snmp: get SaveConfig=%s\n",requests->requestvb->val.string));
        if(*requests->requestvb->val.integer ==1 )
        {
            
            ret = ipc_system_request(IPC_SYS_NVRAM_COMMIT);
            if(ret<0)
            {					
					snmp_log(LOG_ERR, "snmp set handle_SaveConfig to master fail!\n");
					return SNMP_ERR_GENERR;                
            }
        }
		else
		{
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
		}
        break;        
        
    case MODE_SET_COMMIT:
		#if 0
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
		#endif
        break;
    case MODE_SET_UNDO:

		 #if 0
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
		#endif
        break;
     case MODE_SET_FREE:

        break;
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_SaveConfig\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_hw_version(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char val[120] = {0};
	
	sys_info_t *info;
	ipc_sys_info_ack_t *pack;
	//int ret = 0;
	pack = ipc_sys_info(ipc_fd);
	
	if (pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		info = &pack->info;
        strncpy(val, info->hw_version, sizeof(val));
	}
	if(pack) free(pack);	
	

	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		/*if (catv_op_get_version(&version) == CATV_OP_OK){
			ulong_ret = (version.ven_id << 24) + (version.dev_id << 16)
				+ (version.sw_version << 8) + version.hw_version;
		}*/	
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVersionInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_sw_version(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char val[120] = {0};
	
	sys_info_t *info;
	ipc_sys_info_ack_t *pack;
	//int ret = 0;
	pack = ipc_sys_info(ipc_fd);
	
	if (pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		info = &pack->info;
        strncpy(val, info->sw_version, sizeof(val));
	}
	if(pack) free(pack);	
	

	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		/*if (catv_op_get_version(&version) == CATV_OP_OK){
			ulong_ret = (version.ven_id << 24) + (version.dev_id << 16)
				+ (version.sw_version << 8) + version.hw_version;
		}*/	
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVersionInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_buildtime(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char val[120] = {0};
	
	sys_info_t *info;
	ipc_sys_info_ack_t *pack;
	//int ret = 0;
	pack = ipc_sys_info(ipc_fd);
	
	if (pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		info = &pack->info;
        strncpy(val, info->buildtime, sizeof(val));
	}
	if(pack) free(pack);	
	

	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		/*if (catv_op_get_version(&version) == CATV_OP_OK){
			ulong_ret = (version.ven_id << 24) + (version.dev_id << 16)
				+ (version.sw_version << 8) + version.hw_version;
		}*/	
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVersionInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_sysmac(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char val[120] = {0};
	
	sys_info_t *info;
	ipc_sys_info_ack_t *pack;
	//int ret = 0;
	char macstr[24];
	
	pack = ipc_sys_info(ipc_fd);
	
	if (pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		info = &pack->info;
		strcpy(macstr, mac2str(&info->sysmac));
		
        strncpy(val, macstr, sizeof(val));
	}
	if(pack) free(pack);	
	

	
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		/*if (catv_op_get_version(&version) == CATV_OP_OK){
			ulong_ret = (version.ven_id << 24) + (version.dev_id << 16)
				+ (version.sw_version << 8) + version.hw_version;
		}*/	
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)val, strlen(val));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_comDeviceVersionInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


