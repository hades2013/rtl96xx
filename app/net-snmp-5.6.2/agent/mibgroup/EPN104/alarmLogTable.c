/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "alarmLogTable.h"

#include "../product_common/snmp_ipc_interfaceTC.h"
#include <signal.h>

#define ANALOG_OID_LEN  13 

typedef struct {
    long            alarmLogIndex;
    char         alarmLogInformation[ALARMLOGINFO_MAX_LEH];
    size_t          alarmLogInformation_len;
}snmp_alarmLogTable_t;
snmp_alarmLogTable_t g_alarmLogTable;
int alarmLogIndexNum = 1;
int alarmLogLastIndexNum = 0;
int alarmLogNumberEntries = 0;

const oid analogOid[ANALOGNODENUM][ANALOG_OID_LEN] =
	{{1,3,6,1,4,1,17409,1,9,3,1,2,1},
    {1,3,6,1,4,1,17409,1,9,5,1,4,1},
    {1,3,6,1,4,1,17409,1,9,8,1,2,1}};
#if defined(CONFIG_ZBL_SNMP)
void get_alarmLogInformation(int index,snmp_alarmLogTable_t *info, AnalogProperty_t *pinfo, size_t analogOid_len)
{
	CATV_WORK_INFO_S *CATVWorkInfo;
	u_long res;
	uint8_t *oid2ber_v = NULL;
	oid nscrtvRoot_oid = 0;
	int i = 0;
	int j = 0;
	
	res = netsnmp_get_agent_uptime()/100;
	for(i=3;i>=0;i--)
    {
    	info->alarmLogInformation[i] = res;
    	res>>=8;
    }

	info->alarmLogInformation[4] = pinfo->AnalogAlarmPropertyTable[index].analogAlarmState;
	info->alarmLogInformation[5] = info->alarmLogInformation[5]&0x00;
	for(i = 0; i < ANALOGNODENUM; i++)
	{
		if((2 == pinfo->AnalogAlarmPropertyTable[i].analogAlarmState) || (5 == pinfo->AnalogAlarmPropertyTable[i].analogAlarmState))
		{
			info->alarmLogInformation[5] = info->alarmLogInformation[5] | 0x08;
		}
		if((3 == pinfo->AnalogAlarmPropertyTable[i].analogAlarmState) || (4 == pinfo->AnalogAlarmPropertyTable[i].analogAlarmState))
		{
			info->alarmLogInformation[5] = info->alarmLogInformation[5] | 0x10;
		}
	}
	info->alarmLogInformation[6] = 0x06;
	info->alarmLogInformation[7] = analogOid_len + 1;
	info->alarmLogInformation[8] = analogOid[index][0]*40 + analogOid[index][1];
	oid2ber_v = info->alarmLogInformation;
	oid2ber_v = oid2ber_v + 9;
	for(i = 0; i < analogOid_len-2; i++)
	{
		if(analogOid[index][i+2] < 127)
		{
			/*1byte*/
			*oid2ber_v = analogOid[index][i+2];
		}
		else if(analogOid[index][i+2] < 16384)
		{
			/*2 byte*/
			nscrtvRoot_oid = analogOid[index][i+2];
			
			for(j = 0; j < 1; j++)
			{				
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) & 0x7f;
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) | 0x80;
				oid2ber_v ++;
			}
			*oid2ber_v = nscrtvRoot_oid & 0x7f;
		}
		else if(analogOid[index][i+2] < 2097152)
		{
			/*3 byte*/
			nscrtvRoot_oid = analogOid[index][i+2];			
			for(j = 2; j > 0; j--)
			{				
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) & 0x7f;
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) | 0x80;
				oid2ber_v ++;
			}
			*oid2ber_v = nscrtvRoot_oid & 0x7f;
		}
		else
		{
			/*4 byte*/
			nscrtvRoot_oid = analogOid[index][i+2];
			
			for(j = 0; j < 3; j++)
			{
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) & 0x7f;
				*oid2ber_v = (nscrtvRoot_oid>>(j*7)) | 0x80;
				oid2ber_v ++;
			}
			*oid2ber_v = nscrtvRoot_oid&0x7f;
		}
		oid2ber_v ++;
	}

	CATVWorkInfo = CATV_WorkInfoShmInit();
    if(!CATVWorkInfo)
    {
        return -1;
    }
	
	*oid2ber_v = 0x02;
	oid2ber_v ++;
	*oid2ber_v = 0x01;
	oid2ber_v++;
	if(0 == index)
	{
		*oid2ber_v = CATVWorkInfo->input_laser_power_mw;
	}
	else if(1 == index)
	{
		*oid2ber_v = CATVWorkInfo->output_level;
	}
	else if(2 == index)
	{
		*oid2ber_v = CATVWorkInfo->power_12v;
	}
}
#endif
void
send_alarmtrap(int index, AnalogProperty_t *pinfo)
{
	const oid analogalarmOid[] = {1,3,6,1,4,1,17409,1,1};
	snmp_alarmLogTable_t *info = NULL;
	uint8_t commonDeviceMACAddress[ETHER_ADDR_LEN];
	char   alarmText[ALARMLOGINFO_MAX_LEH] = "current: ";
	
	info = &g_alarmLogTable;
	info->alarmLogIndex = alarmLogIndexNum;
	size_t	 analogOid_len = OID_LENGTH(analogOid[index]);
	
/*get alarmLogInformation*/
#if defined(CONFIG_ZBL_SNMP)
	get_alarmLogInformation(index,info,pinfo,analogOid_len);
#endif
/*Begin get mac*/
	sys_network_t info_mac;
	ipc_sys_network_ack_t *pack_mac;
				
	pack_mac = ipc_sys_networking(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack_mac && pack_mac->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info_mac, &pack_mac->network, sizeof(info_mac));
		memcpy(commonDeviceMACAddress, &(info_mac.mac.octet), sizeof(commonDeviceMACAddress)); 
	}
	if(pack_mac) free(pack_mac);
/*End get mac*/
/*Begin get commonNELogicalID*/
	commonAdminGroup_t pinfo_logicalid ;
	ipc_commonAdminGroup_ack_t *pack_logicalid = NULL;
	char NELogicalID[COMMONDEVICESID_MAX];
	
	memset(&pinfo_logicalid, 0, sizeof(commonAdminGroup_t));
	memset(NELogicalID, 0, sizeof(NELogicalID));
	pack_logicalid = ipc_commonAdminGroup(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack_logicalid && pack_logicalid->hdr.status == IPC_STATUS_OK) 
	{		
		memcpy(&pinfo_logicalid, &pack_logicalid->commonAdminGroup, sizeof(commonAdminGroup_t));
		memcpy(NELogicalID, pinfo_logicalid.commonNELogicalID, sizeof(NELogicalID));

		if(pack_logicalid)
		{
			free(pack_logicalid);
		}
	}
	else
	{	
		if(pack_logicalid)
		{
			free(pack_logicalid);
		}
		return SNMP_ERR_GENERR;
	}
/*End get commonNELogicalID*/

	//strncpy(alarmText, "current: ", sizeof(alarmText));

	oid 			objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
	size_t			objid_snmptrap_len = OID_LENGTH(objid_snmptrap);

	size_t			analogalarmOid_len = OID_LENGTH(analogalarmOid);

	oid 			mac_oid[] = { 1, 3, 6, 1, 4, 1, 17409,1 , 3, 2, 1, 1, 1, 0};
	size_t			mac_oid_len = OID_LENGTH(mac_oid);
	
	oid 			logic_oid[] = { 1, 3, 6, 1, 4, 1, 17409,1 , 3, 1, 1, 0};
	size_t			logic_oid_len = OID_LENGTH(logic_oid);

	oid 			alarmText_oid[] = { 1, 3, 6, 1, 4, 1, 17409,1 , 2, 4, 0};
	size_t			alarmText_oid_len = OID_LENGTH(alarmText_oid);

	oid 			alarmLogInformation_oid[13] = { 1, 3, 6, 1, 4, 1, 17409,1 , 2, 3, 1, 2};
	alarmLogInformation_oid[12] = alarmLogIndexNum;
	size_t			alarmLogInformation_oid_len = OID_LENGTH(alarmLogInformation_oid);

	netsnmp_variable_list *notification_vars = NULL;

	DEBUGMSGTL(("netsnmp_udp", "defining the trap\n"));

	/*
	 * add in the trap definition object 
	 有多少数据要发送，就调用snmp_varlist_add_variable()多少次
	 */
	snmp_varlist_add_variable(&notification_vars,
							  objid_snmptrap, objid_snmptrap_len,
							  ASN_OBJECT_ID,
							  (u_char *) analogalarmOid,
							  analogalarmOid_len * sizeof(oid));

	/*
	 * add in the additional objects defined as part of the trap
	 */
#if 1
	snmp_varlist_add_variable(&notification_vars,
							   mac_oid, mac_oid_len,
							   ASN_OCTET_STR,
							  (u_char *)commonDeviceMACAddress,
							   sizeof(commonDeviceMACAddress));
#endif
	snmp_varlist_add_variable(&notification_vars,
							   logic_oid, logic_oid_len,
							   ASN_OCTET_STR,
							  (u_char *)NELogicalID,
							   strlen(NELogicalID));

	snmp_varlist_add_variable(&notification_vars,
						   alarmLogInformation_oid, alarmLogInformation_oid_len,
						   ASN_OCTET_STR,
						   info->alarmLogInformation,
						   25 * sizeof(char));
	#if 1
	snmp_varlist_add_variable(&notification_vars,
							   alarmText_oid, alarmText_oid_len,
							   ASN_OCTET_STR,
							  (u_char *)alarmText,
							   strlen(alarmText));
	#endif
	send_v2trap(notification_vars);
	/*
	 * free the created notification variable list 
	 */
	DEBUGMSGTL(("netsnmp_udp", "cleaning up\n"));
	snmp_free_varbind(notification_vars);
}


static void signal_handler(int sig)
{
    int val; 
	ipc_analogPropertyTable_ack_t *pack = NULL;
	AnalogProperty_t pinfo;
	
	if(SIGUSR1 == sig)
    {
        alarmLogNumberEntries++;
		alarmLogIndexNum++;
		if(alarmLogIndexNum > 32736) 
	    {   
	        alarmLogIndexNum = 1;
	    }
		if(alarmLogNumberEntries >= 16)
	    {   
	        alarmLogNumberEntries = 16;
	    }
		alarmLogLastIndexNum = alarmLogIndexNum - 1;
		pack = ipc_analogPropertyTable(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
		if(pack && pack->hdr.status == IPC_STATUS_OK) 
		{		
			memcpy(&pinfo , &pack->AnalogProperty, sizeof(AnalogProperty_t));

			if(pack)
			{
				free(pack);
			}
		}
		else
		{	
			if(pack)
			{
				free(pack);
			}		
		}
		send_alarmtrap(pinfo.index, &pinfo);
    }
}

/** Initializes the alarmLogTable module */
void
init_alarmLogTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_alarmLogTable();
}

//# Determine the first/last column names

/** Initialize the alarmLogTable table by defining its contents and how it's structured */
void
initialize_table_alarmLogTable(void)
{
    const oid       alarmLogTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 1, 2, 3 };
    const size_t    alarmLogTable_oid_len = OID_LENGTH(alarmLogTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;
	int i = 0;
	
    DEBUGMSGTL(("alarmLogTable:init",
                "initializing table alarmLogTable\n"));
	#if 0
	sys_info_t info;
	ipc_sys_info_ack_t *pack;
	pack = ipc_sys_info(ipc_fd);

	memset(&info, 0, sizeof(info));
	
	if (pack && pack->hdr.status == IPC_STATUS_OK) 
	{
		memcpy(&info, &(pack->info), sizeof(info));
	}
	if(pack) free(pack);
	#endif
	g_alarmLogTable.alarmLogIndex = 1;

	for(i=3;i>=0;i--)
    {
    	g_alarmLogTable.alarmLogInformation[i]=0;
    	//info.uptime>>=8;
    }
	
	g_alarmLogTable.alarmLogInformation[4] = 3;
	g_alarmLogTable.alarmLogInformation[5] = 1;
	g_alarmLogTable.alarmLogInformation_len = sizeof(g_alarmLogTable.alarmLogInformation);

    reg =
        netsnmp_create_handler_registration("alarmLogTable",
                                            alarmLogTable_handler,
                                            alarmLogTable_oid,
                                            alarmLogTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: alarmLogIndex */
                                     0);
    table_info->min_column = COLUMN_ALARMLOGINDEX;
    table_info->max_column = COLUMN_ALARMLOGINFORMATION;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = alarmLogTable_get_first_data_point;
    iinfo->get_next_data_point = alarmLogTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);
	netsnmp_inject_handler( reg,
						netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
								alarmLogTable_load, alarmLogTable_free,
								alarmLogTable_oid, OID_LENGTH(alarmLogTable_oid)));
				DEBUGMSGTL(("alarmLogTable",
							"initialize alarmLogTable\n")); 
	signal(SIGUSR1, signal_handler);

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct alarmLogTable_entry {
    /*
     * Index values 
     */
    long            alarmLogIndex;

    /*
     * Column values 
     */
    //long            alarmLogIndex;
    char            alarmLogInformation[ALARMLOGINFO_MAX_LEH];
    size_t          alarmLogInformation_len;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct alarmLogTable_entry *next;
};

struct alarmLogTable_entry *alarmLogTable_head;

/*
 * create a new row in the (unsorted) table 
 */
struct alarmLogTable_entry *
alarmLogTable_createEntry(struct alarmLogTable_entry *alarmLogTable)
{
    struct alarmLogTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct alarmLogTable_entry);
    if (!entry)
        return NULL;

    //entry->alarmLogIndex = alarmLogIndex;
    memcpy(entry, alarmLogTable, sizeof(*entry));
    entry->next = alarmLogTable_head;
    alarmLogTable_head = entry;
    return entry;
}


void alarmLogTable_setEntry(
				struct alarmLogTable_entry *entry, 
				snmp_alarmLogTable_t *pinfo
				)
{

	memset(entry, 0, sizeof(*entry));
	
	entry->alarmLogIndex = pinfo->alarmLogIndex;
	memcpy(entry->alarmLogInformation, pinfo->alarmLogInformation, sizeof(entry->alarmLogInformation));
	entry->alarmLogInformation_len = pinfo->alarmLogInformation_len;
}

/*
 * remove a row from the table 
 */
void
alarmLogTable_removeEntry(struct alarmLogTable_entry *entry)
{
    struct alarmLogTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = alarmLogTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        alarmLogTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void alarmLogTable_removeAllEntry(void )
{
    struct alarmLogTable_entry *ptr, *pnext;

    for (ptr = alarmLogTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	alarmLogTable_head = NULL;
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
alarmLogTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
    *my_loop_context = alarmLogTable_head;
    return alarmLogTable_get_next_data_point(my_loop_context,
                                             my_data_context,
                                             put_index_data, mydata);
}

netsnmp_variable_list *
alarmLogTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
    struct alarmLogTable_entry *entry =
        (struct alarmLogTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER, entry->alarmLogIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the alarmLogTable table */
int
alarmLogTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct alarmLogTable_entry *table_entry;

    DEBUGMSGTL(("alarmLogTable:handler", "Processing request (%d)\n",
                reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct alarmLogTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_ALARMLOGINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->alarmLogIndex);
                break;
            case COLUMN_ALARMLOGINFORMATION:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->alarmLogInformation,
                                         table_entry->alarmLogInformation_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}

int alarmLogTable_load(netsnmp_cache *cache, void *vmagic)
{
	int ret = 0;
	struct alarmLogTable_entry entry;
	u_long			res;
	int i = 0;

	snmp_alarmLogTable_t *info = NULL;
	AnalogProperty_t pinfo;
	ipc_analogPropertyTable_ack_t *pack = NULL;

	/* Free All */
	alarmLogTable_removeAllEntry();
	info = &g_alarmLogTable;
	info->alarmLogIndex = alarmLogIndexNum;
	size_t	 analogOid_len = OID_LENGTH(analogOid[pinfo.index]);
	
	pack = ipc_analogPropertyTable(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
	if(pack && pack->hdr.status == IPC_STATUS_OK) 
	{		
		memcpy(&pinfo , &pack->AnalogProperty, sizeof(AnalogProperty_t));

		if(pack)
		{
			free(pack);
		}
	}
	else
	{	
		if(pack)
		{
			free(pack);
		}		
	}
#if defined(CONFIG_ZBL_SNMP)
	get_alarmLogInformation(pinfo.index,info,&pinfo,analogOid_len);
#endif	
	alarmLogTable_setEntry(&entry, info);	
	alarmLogTable_createEntry(&entry);	

safe_exit:
	
	HC_IPC_ASSERT(ret);
	
    return ret; 
} 


void alarmLogTable_free(netsnmp_cache *cache, void *magic)
{
	DEBUGMSGTL(("alarmLogTable", "Free alarmLogTable Group\n"));  
}

