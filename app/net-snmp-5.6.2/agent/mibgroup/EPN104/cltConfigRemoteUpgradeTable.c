/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltConfigRemoteUpgradeTable.h"

#include "memshare.h"
#include "shutils.h"
#include "../product_common/snmp_ipc_interfaceTC.h"
#include "ufile_process.h" 
#include "ufile.h"
#include "trap.h"
#include <signal.h>
#include "pdt_config.h"//add by zhouguanhua 2013/5/6 for bug id 41
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif



#include <net-snmp/net-snmp-config.h>

#if HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#if HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif

#if HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif


#define DBGTOKEN  				"cltConfigRemoteUpgradeTable" 
#define DEFAULT_ENABLE 	 		1
#define DEFAULT_CURRENTPCIP		"192.168.0.123"
#define DEFAULT_USERNAME		"admin"
#define DEFAULT_PASSWORD		"admin"
#define DEFAULT_INTERVAL		0
#define DEFAULT_SUBMIT			0

#define SUBMIT_ENABLE			1 
#define SUBMIT_DISABLE 			0
#define ENABLE 					1
#define REMOTEUPGRADE_OK							 0
#define REMOTEUPGRADE_OTHER_ERROR					-1
#define REMOTEUPGRADE_NOTBINTYPE					-2
#define REMOTEUPGRADE_DOWNLOAD_FILE_FAIL			-3
#define REMOTEUPGRADE_OPEN_FILE_FAIL				-4	
#define REMOTEUPGRADE_FILE_CHECK_ERROR 				-5	
#define REMOTEUPGRADE_UPGRADE_APP_ERROR				-6
#define REMOTEUPGRADE_FILE_NOT_EXIST				-7
#define REMOTEUPGRADE_DISABLE						-8
#define REMOTEUPGRADE_USERNAME_PASSWD_ERROR			-9


#define MAX_STRING_SIZE 32
#define MAX_BUF_SIZE ((MAX_STRING_SIZE)*2 + 15 + 30)

#define STRMAX 	1024

typedef struct {
	long 			index;
    long            enable;
	long            old_enable;
	
    in_addr_t       current_pc_ip;
	in_addr_t       old_current_pc_ip;
	
	char            filename[MAX_STRING_SIZE];
	size_t			filename_len;
	char            old_filename[MAX_STRING_SIZE];
	size_t			old_filename_len;
	
    char           	username[MAX_ADMIN_NAME_SIZE];	
	size_t			username_len;
	char           	old_username[MAX_ADMIN_NAME_SIZE];	
	size_t			old_username_len;
	
    char            password[MAX_ADMIN_PWD_SIZE];
	size_t			password_len;
	char            old_password[MAX_ADMIN_PWD_SIZE];
	size_t			old_password_len;

	long			interval;
	long			old_interval;
	
	long			submit;
	long			old_submit;

}remoteUpgrade_t;

remoteUpgrade_t g_remoteUpgradeInfo;

struct in_addr current_pc_ip;

#define DEFAULT_COMMIT_DELAY 1
LOCAL_COMMIT_DECLARE();

#define RemoteUpgrade_local_commit(x)  LOCAL_COMMIT(DEFAULT_COMMIT_DELAY, cltConfigRemoteUpgradeTable_commit, (void *)(x))

/** Initializes the cltConfigRemoteUpgradeTable module */
void
init_cltConfigRemoteUpgradeTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_cltConfigRemoteUpgradeTable();
}


/** Initialize the cltConfigRemoteUpgradeTable table by defining its contents and how it's structured */
void
initialize_table_cltConfigRemoteUpgradeTable(void)
{
    static oid      cltConfigRemoteUpgradeTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 17409, 1, 16, 2 };
    size_t          cltConfigRemoteUpgradeTable_oid_len =
        OID_LENGTH(cltConfigRemoteUpgradeTable_oid);

	char   default_filename[MAX_STRING_SIZE] = {0};
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL((DBGTOKEN,
                "initializing table cltConfigRemoteUpgradeTable\n"));

	g_remoteUpgradeInfo.index = 0;
	
	g_remoteUpgradeInfo.enable = DEFAULT_ENABLE;
	g_remoteUpgradeInfo.old_enable = DEFAULT_ENABLE;
	
	g_remoteUpgradeInfo.current_pc_ip = inet_addr(DEFAULT_CURRENTPCIP);
	g_remoteUpgradeInfo.old_current_pc_ip = inet_addr(DEFAULT_CURRENTPCIP);

	sprintf(default_filename, "%s.bin",CONFIG_RELEASE_VER);
	strncpy(g_remoteUpgradeInfo.filename, default_filename, sizeof(g_remoteUpgradeInfo.filename));
	g_remoteUpgradeInfo.filename_len = strlen(g_remoteUpgradeInfo.filename);
	strncpy(g_remoteUpgradeInfo.old_filename, default_filename, sizeof(g_remoteUpgradeInfo.old_filename));
	g_remoteUpgradeInfo.old_filename_len = strlen(g_remoteUpgradeInfo.old_filename);
	
	strncpy(g_remoteUpgradeInfo.username, DEFAULT_USERNAME, sizeof(g_remoteUpgradeInfo.username));
	g_remoteUpgradeInfo.username_len = strlen(g_remoteUpgradeInfo.username);
	strncpy(g_remoteUpgradeInfo.old_username, DEFAULT_USERNAME, sizeof(g_remoteUpgradeInfo.old_username));
	g_remoteUpgradeInfo.old_username_len = strlen(g_remoteUpgradeInfo.old_username);
	
	strncpy(g_remoteUpgradeInfo.password, DEFAULT_PASSWORD, sizeof(g_remoteUpgradeInfo.password));
	g_remoteUpgradeInfo.password_len = strlen(g_remoteUpgradeInfo.password);
	strncpy(g_remoteUpgradeInfo.old_password, DEFAULT_PASSWORD, sizeof(g_remoteUpgradeInfo.old_password));
	g_remoteUpgradeInfo.old_password_len = strlen(g_remoteUpgradeInfo.old_password);

	g_remoteUpgradeInfo.interval = DEFAULT_INTERVAL;
	g_remoteUpgradeInfo.old_interval = DEFAULT_INTERVAL;
	
	g_remoteUpgradeInfo.submit = DEFAULT_SUBMIT;
	g_remoteUpgradeInfo.old_submit = DEFAULT_SUBMIT;

	cltConfigRemoteUpgradeTable_load( NULL, NULL );
	
    reg =
        netsnmp_create_handler_registration("cltConfigRemoteUpgradeTable",
                                            cltConfigRemoteUpgradeTable_handler,
                                            cltConfigRemoteUpgradeTable_oid,
                                            cltConfigRemoteUpgradeTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: cltConfigRemoteUpgradeIndex */
                                     0);
    table_info->min_column = COLUMN_CLTCONFIGREMOTEUPGRADEINDEX;
    table_info->max_column = COLUMN_REMOTEUPGRADESUBMIT;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        cltConfigRemoteUpgradeTable_get_first_data_point;
    iinfo->get_next_data_point =
        cltConfigRemoteUpgradeTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);
	netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(CLTCONFIGREMOTEUPGRADETABLE_TIMEOUT,
			   		cltConfigRemoteUpgradeTable_load, cltConfigRemoteUpgradeTable_free,
					cltConfigRemoteUpgradeTable_oid, cltConfigRemoteUpgradeTable_oid_len));
    DEBUGMSGTL((DBGTOKEN,"initialize cltConfigRemoteUpgradeTable\n"));   
    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct cltConfigRemoteUpgradeTable_entry {
    /*
     * Index values 
     */
    long            cltConfigRemoteUpgradeIndex;

    /*
     * Column values 
     */
    long            remoteUpgradeEnable;
    long            old_remoteUpgradeEnable;
    in_addr_t       remoteUpgradeCurrentPcIP;
    in_addr_t       old_remoteUpgradeCurrentPcIP;
    char            cltConfigRemoteUpgradeFileName[MAX_STRING_SIZE];
    size_t          cltConfigRemoteUpgradeFileName_len;
    char            old_cltConfigRemoteUpgradeFileName[MAX_STRING_SIZE];
    size_t          old_cltConfigRemoteUpgradeFileName_len;
    char            remoteUpgradeUsername[MAX_ADMIN_NAME_SIZE];
    size_t          remoteUpgradeUsername_len;
    char            old_remoteUpgradeUsername[MAX_ADMIN_NAME_SIZE];
    size_t          old_remoteUpgradeUsername_len;
    char            remoteUpgradePassword[MAX_ADMIN_PWD_SIZE];
    size_t          remoteUpgradePassword_len;
    char            old_remoteUpgradePassword[MAX_ADMIN_PWD_SIZE];
    size_t          old_remoteUpgradePassword_len;
    long            cltConfigRemoteUpgradeInterval;
    long            old_cltConfigRemoteUpgradeInterval;
    long            remoteUpgradeSubmit;
    long            old_remoteUpgradeSubmit;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
	u_long 			row_updates;
	long 			value_bottom, value_top;
	int 			type, alarms_id;
	u_long 			event_value;
    struct cltConfigRemoteUpgradeTable_entry *next;
};

struct cltConfigRemoteUpgradeTable_entry *cltConfigRemoteUpgradeTable_head = NULL;
struct cltConfigRemoteUpgradeTable_entry *cltConfigRemoteUpgradeTable_commit_head = NULL;




void cltConfigRemoteUpgradeTable_setEntry(
				struct cltConfigRemoteUpgradeTable_entry *entry, 
				remoteUpgrade_t *pinfo)
{

	memset(entry, 0, sizeof(*entry));
	
	entry->cltConfigRemoteUpgradeIndex = pinfo->index;
	
	entry->remoteUpgradeEnable = pinfo->enable;
	entry->old_remoteUpgradeEnable = pinfo->old_enable;
	
	entry->remoteUpgradeCurrentPcIP = pinfo->current_pc_ip;
	entry->old_remoteUpgradeCurrentPcIP = pinfo->old_current_pc_ip;

	strncpy(entry->cltConfigRemoteUpgradeFileName, pinfo->filename, sizeof(entry->cltConfigRemoteUpgradeFileName));
	entry->cltConfigRemoteUpgradeFileName_len = pinfo->filename_len;	
	strncpy(entry->old_cltConfigRemoteUpgradeFileName, pinfo->old_filename, sizeof(entry->old_cltConfigRemoteUpgradeFileName));
	entry->old_cltConfigRemoteUpgradeFileName_len = pinfo->old_filename_len;
	
	strncpy(entry->remoteUpgradeUsername, pinfo->username, sizeof(entry->remoteUpgradeUsername));
	entry->remoteUpgradeUsername_len = pinfo->username_len;	
	strncpy(entry->old_remoteUpgradeUsername, pinfo->old_username, sizeof(entry->old_remoteUpgradeUsername));
	entry->old_remoteUpgradeUsername_len = pinfo->old_username_len;
	
	strncpy(entry->remoteUpgradePassword, pinfo->password, sizeof(entry->remoteUpgradePassword));
	entry->remoteUpgradePassword_len = pinfo->password_len;
	strncpy(entry->old_remoteUpgradePassword, pinfo->old_password, sizeof(entry->old_remoteUpgradePassword));
	entry->old_remoteUpgradePassword_len = pinfo->old_password_len;

	entry->cltConfigRemoteUpgradeInterval = pinfo->interval;
	entry->old_cltConfigRemoteUpgradeInterval = pinfo->old_interval;
	
	entry->remoteUpgradeSubmit = pinfo->submit;
	entry->old_remoteUpgradeSubmit = pinfo->old_submit;
	
	return;
}


/*
 * create a new row in the (unsorted) table 
 */
struct cltConfigRemoteUpgradeTable_entry *
cltConfigRemoteUpgradeTable_createEntry(struct cltConfigRemoteUpgradeTable_entry *cltConfigRemoteUpgradeTable)
{
    struct cltConfigRemoteUpgradeTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltConfigRemoteUpgradeTable_entry);
    if (!entry)
        return NULL;

    memcpy(entry, cltConfigRemoteUpgradeTable, sizeof(*entry));
    entry->next = cltConfigRemoteUpgradeTable_head;
    cltConfigRemoteUpgradeTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
cltConfigRemoteUpgradeTable_removeEntry(struct
                                        cltConfigRemoteUpgradeTable_entry
                                        *entry)
{
    struct cltConfigRemoteUpgradeTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = cltConfigRemoteUpgradeTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltConfigRemoteUpgradeTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void cltConfigRemoteUpgradeTable_removeAllEntry(void )
{
    struct cltConfigRemoteUpgradeTable_entry *ptr, *pnext;

    for (ptr = cltConfigRemoteUpgradeTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigRemoteUpgradeTable_head = NULL;
}

void cltConfigRemoteUpgradeTable_removeAllCommitEntry(void )
{
    struct cltConfigRemoteUpgradeTable_entry *ptr, *pnext;

    for (ptr = cltConfigRemoteUpgradeTable_commit_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigRemoteUpgradeTable_commit_head = NULL;

	return;
}



struct cltConfigRemoteUpgradeTable_entry *
cltConfigRemoteUpgradeTable_backupCommitEntry(
				struct cltConfigRemoteUpgradeTable_entry *cltConfigRemoteUpgradeTable)
{
    struct cltConfigRemoteUpgradeTable_entry *entry, *next;

	#if 1
	/*
    	for (entry = opRxInputTable_commit_head; entry != NULL; entry = entry->next) {
		if ((entry->analogAlarmParameterOID_len == opRxInputTable->analogAlarmParameterOID_len)
			&& !memcmp(entry->analogAlarmParameterOID, opRxInputTable->analogAlarmParameterOID, entry->analogAlarmParameterOID_len)){
			break;
		}		
    	}	
    */
    for(entry = cltConfigRemoteUpgradeTable_commit_head; entry != NULL; entry = entry->next) 
    {	
    	if(entry->cltConfigRemoteUpgradeIndex == cltConfigRemoteUpgradeTable->cltConfigRemoteUpgradeIndex)
    	{
    		break;
    	}
    }
    
	#endif	

	if (!entry){
		entry = SNMP_MALLOC_TYPEDEF(struct cltConfigRemoteUpgradeTable_entry);
		if (!entry)
			return NULL;
		entry->next = cltConfigRemoteUpgradeTable_commit_head;
		cltConfigRemoteUpgradeTable_commit_head = entry;
	}

	
	next = entry->next;
	memcpy(entry, cltConfigRemoteUpgradeTable, sizeof(*entry));
	entry->next = next;
	
    return entry;	
}


/*
 * Example cache handling - set up linked list from a suitable file 
 */
int
cltConfigRemoteUpgradeTable_load(netsnmp_cache * cache, void *vmagic)
{
	struct cltConfigRemoteUpgradeTable_entry entry;
		
	int ret = 0;
	int i;
	remoteUpgrade_t *pinfo = NULL;
	int remoteUpgrade_num;

	COMMIT_PENDING_ASSERT();

	/* Free All */
	cltConfigRemoteUpgradeTable_removeAllEntry();

	/* Load All */
	remoteUpgrade_num = 1;
	/*alarms_num =ipc_snmp_alarm_num(&agent)*/
	if (remoteUpgrade_num == 0){
		DBG_ASSERT(0, "remoteUpgrade num is 0");
		return 0;
	}

	pinfo = &g_remoteUpgradeInfo;
	
	#if 0
	ret = ipc_snmp_alarm_get(&agent, pinfo, &alarms_num);
	if (HC_IPC_ERROR(ret)) {
		goto safe_exit;
	}
	#endif
	
	for (i = 0; i < remoteUpgrade_num; i ++)
	{
		cltConfigRemoteUpgradeTable_setEntry(&entry, &pinfo[i]);	
		if(NULL == cltConfigRemoteUpgradeTable_createEntry(&entry))
		{
			DEBUGMSGTL((DBGTOKEN,"error:createEntry\n"));
		}
	}

safe_exit:
	
	HC_IPC_ASSERT(ret);
	
    return ret; 


	#if 0
    FILE           *fp;
    struct cltConfigRemoteUpgradeTable_entry *this;
    char            buf[STRMAX];

    /*
     * The basic load routine template assumes that the data to
     * be reported is held in a file - with one row of the file
     * for each row of the table.
     * If your data is available via a different API, you
     * should amend this initial block (and the control of the
     * 'while' loop) accordingly.
     * 'XXX' marks where the template is incomplete and
     * code will definitely need to be added. 
     */

    fp = fopen("/data/for/cltConfigRemoteUpgradeTable", "r");
    if (!fp) {
        return -1;
    }
    while (fgets(buf, STRMAX, fp)) {
        this =
            SNMP_MALLOC_TYPEDEF(struct cltConfigRemoteUpgradeTable_entry);
        /*
         * XXX - Unpick 'buf' to extract the individual field values
         * and then populate the 'this' data structure with them 
         */

        this->next = cltConfigRemoteUpgradeTable_head;
        cltConfigRemoteUpgradeTable_head = this;        /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;                   /* OK */
	#endif
}

void
cltConfigRemoteUpgradeTable_free(netsnmp_cache * cache, void *vmagic)
{
	DEBUGMSGTL((DBGTOKEN, "Free cltConfigRemoteUpgradeTable Group\n"));  
	#if 0
    struct cltConfigRemoteUpgradeTable_entry *this, *that;

    for (this = cltConfigRemoteUpgradeTable_head; this; this = that) {
        that = this->next;
        SNMP_FREE(this);        /* XXX - release any other internal resources */
    }
    cltConfigRemoteUpgradeTable_head = NULL;
	#endif
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
cltConfigRemoteUpgradeTable_get_first_data_point(void **my_loop_context,
                                                 void **my_data_context,
                                                 netsnmp_variable_list *
                                                 put_index_data,
                                                 netsnmp_iterator_info
                                                 *mydata)
{
    *my_loop_context = cltConfigRemoteUpgradeTable_head;
    return cltConfigRemoteUpgradeTable_get_next_data_point(my_loop_context,
                                                           my_data_context,
                                                           put_index_data,
                                                           mydata);
}

netsnmp_variable_list *
cltConfigRemoteUpgradeTable_get_next_data_point(void **my_loop_context,
                                                void **my_data_context,
                                                netsnmp_variable_list *
                                                put_index_data,
                                                netsnmp_iterator_info
                                                *mydata)
{
    struct cltConfigRemoteUpgradeTable_entry *entry =
        (struct cltConfigRemoteUpgradeTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->cltConfigRemoteUpgradeIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


static int cltConfigRemoteUpgradeTable_checkEntry(struct cltConfigRemoteUpgradeTable_entry *ptr)
{	
	#if 0
	if (ptr){
		if (ptr->value_bottom < ptr->value_top){
			if ((ptr->value_bottom <= ptr->dorInputStatus)
				&& (ptr->dorInputStatus <= ptr->dorInputWavelengthControl)
				&& (ptr->dorInputWavelengthControl <= ptr->dorInputPower)){
				return 1;
			}
		}else {
			if ((ptr->value_top <= ptr->dorInputPower)
				&& (ptr->dorInputPower <= ptr->dorInputWavelengthControl)
				&& (ptr->dorInputWavelengthControl <= ptr->dorInputStatus)
				&& (ptr->dorInputStatus <= ptr->value_bottom)){
				return 1;
			}
		}
	}
	#endif
	return 1;
}


/** handles requests for the cltConfigRemoteUpgradeTable table */
int
cltConfigRemoteUpgradeTable_handler(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{	
	int count = 0;
	int ret;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct cltConfigRemoteUpgradeTable_entry *table_entry;

    if (((reqinfo->mode == MODE_GET) /*|| (reqinfo->mode == MODE_SET_ACTION)*/) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        //netsnmp_assert(!"cache == valid"); /* always false */
        //cltConfigRemoteUpgradeTable_load( NULL, NULL );	/* XXX - check for failure */
    }
	
	DEBUGMSGTL((DBGTOKEN, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigRemoteUpgradeTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGREMOTEUPGRADEINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }			
				
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigRemoteUpgradeIndex);
				
				break;
            case COLUMN_REMOTEUPGRADEENABLE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }			
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->remoteUpgradeEnable);
			
                break;
            case COLUMN_REMOTEUPGRADECURRENTPCIP:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_IPADDRESS,
                                           table_entry->remoteUpgradeCurrentPcIP);
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEFILENAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->cltConfigRemoteUpgradeFileName,
                                         table_entry->cltConfigRemoteUpgradeFileName_len);
				
                break;
            case COLUMN_REMOTEUPGRADEUSERNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->remoteUpgradeUsername,
                                         table_entry->remoteUpgradeUsername_len);
                break;
            case COLUMN_REMOTEUPGRADEPASSWORD:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->remoteUpgradePassword,
                                         table_entry->remoteUpgradePassword_len);
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEINTERVAL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigRemoteUpgradeInterval);
                break;
            case COLUMN_REMOTEUPGRADESUBMIT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->remoteUpgradeSubmit);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigRemoteUpgradeTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_REMOTEUPGRADEENABLE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_REMOTEUPGRADECURRENTPCIP:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_ipaddr(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEFILENAME:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->cltConfigRemoteUpgradeFileName));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_REMOTEUPGRADEUSERNAME:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->remoteUpgradeUsername));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_REMOTEUPGRADEPASSWORD:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->remoteUpgradePassword));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEINTERVAL:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_REMOTEUPGRADESUBMIT:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigRemoteUpgradeTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_REMOTEUPGRADEENABLE:
                table_entry->old_remoteUpgradeEnable =
                    table_entry->remoteUpgradeEnable;
                table_entry->remoteUpgradeEnable =
                    *request->requestvb->val.integer;
				table_entry->row_updates |= (1 << table_info->colnum);
				DEBUGMSGTL((DBGTOKEN,"enable:request->requestvb->val.integer=%ld\n", *request->requestvb->val.integer));	 
                break;
            case COLUMN_REMOTEUPGRADECURRENTPCIP:
                table_entry->old_remoteUpgradeCurrentPcIP =
                    table_entry->remoteUpgradeCurrentPcIP;
                table_entry->remoteUpgradeCurrentPcIP =
                    *request->requestvb->val.integer;
				table_entry->row_updates |= (1 << table_info->colnum);
				
				current_pc_ip.s_addr = *request->requestvb->val.integer;
				DEBUGMSGTL((DBGTOKEN,"currentpcIP:request->requestvb->val.integer=%s\n", inet_ntoa(current_pc_ip)));	 
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEFILENAME:
                memcpy(table_entry->old_cltConfigRemoteUpgradeFileName,
                       table_entry->cltConfigRemoteUpgradeFileName,
                       sizeof(table_entry->cltConfigRemoteUpgradeFileName));
                table_entry->old_cltConfigRemoteUpgradeFileName_len =
                    table_entry->cltConfigRemoteUpgradeFileName_len;
                memset(table_entry->cltConfigRemoteUpgradeFileName, 0,
                       sizeof(table_entry->cltConfigRemoteUpgradeFileName));
                memcpy(table_entry->cltConfigRemoteUpgradeFileName,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltConfigRemoteUpgradeFileName_len =
                    request->requestvb->val_len;
				table_entry->row_updates |= (1 << table_info->colnum);
				DEBUGMSGTL((DBGTOKEN,"filename:request->requestvb->val.string=%s, len=%d\n", request->requestvb->val.string, request->requestvb->val_len));	
                break;
            case COLUMN_REMOTEUPGRADEUSERNAME:
                memcpy(table_entry->old_remoteUpgradeUsername,
                       table_entry->remoteUpgradeUsername,
                       sizeof(table_entry->remoteUpgradeUsername));
                table_entry->old_remoteUpgradeUsername_len =
                    table_entry->remoteUpgradeUsername_len;
                memset(table_entry->remoteUpgradeUsername, 0,
                       sizeof(table_entry->remoteUpgradeUsername));
                memcpy(table_entry->remoteUpgradeUsername,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->remoteUpgradeUsername_len =
                    request->requestvb->val_len;
				table_entry->row_updates |= (1 << table_info->colnum);
				DEBUGMSGTL((DBGTOKEN,"username:request->requestvb->val.string=%s, len=%d\n", request->requestvb->val.string, request->requestvb->val_len));	 
                break;
            case COLUMN_REMOTEUPGRADEPASSWORD:
                memcpy(table_entry->old_remoteUpgradePassword,
                       table_entry->remoteUpgradePassword,
                       sizeof(table_entry->remoteUpgradePassword));
                table_entry->old_remoteUpgradePassword_len =
                    table_entry->remoteUpgradePassword_len;
                memset(table_entry->remoteUpgradePassword, 0,
                       sizeof(table_entry->remoteUpgradePassword));
                memcpy(table_entry->remoteUpgradePassword,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->remoteUpgradePassword_len =
                    request->requestvb->val_len;
				table_entry->row_updates |= (1 << table_info->colnum);
				DEBUGMSGTL((DBGTOKEN,"password:request->requestvb->val.string=%s, len=%d\n", request->requestvb->val.string, request->requestvb->val_len));	 
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEINTERVAL:
                table_entry->old_cltConfigRemoteUpgradeInterval =
                    table_entry->cltConfigRemoteUpgradeInterval;
                table_entry->cltConfigRemoteUpgradeInterval =
                    *request->requestvb->val.integer;
				table_entry->row_updates |= (1 << table_info->colnum);
                break;
            case COLUMN_REMOTEUPGRADESUBMIT:
                table_entry->old_remoteUpgradeSubmit =
                    table_entry->remoteUpgradeSubmit;
                table_entry->remoteUpgradeSubmit =
                    *request->requestvb->val.integer;
				table_entry->row_updates |= (1 << table_info->colnum);
				DEBUGMSGTL((DBGTOKEN,"submit:request->requestvb->val.integer=%ld\n", *request->requestvb->val.integer));	 
                break;
            }
			DEBUGMSGTL((DBGTOKEN,"table_entry->row_updates=%ld\n", table_entry->row_updates));	 
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigRemoteUpgradeTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_REMOTEUPGRADEENABLE:
                table_entry->remoteUpgradeEnable =
                    table_entry->old_remoteUpgradeEnable;
                table_entry->old_remoteUpgradeEnable = 0;
                break;
            case COLUMN_REMOTEUPGRADECURRENTPCIP:
                table_entry->remoteUpgradeCurrentPcIP =
                    table_entry->old_remoteUpgradeCurrentPcIP;
                table_entry->old_remoteUpgradeCurrentPcIP = 0;
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEFILENAME:
                memcpy(table_entry->cltConfigRemoteUpgradeFileName,
                       table_entry->old_cltConfigRemoteUpgradeFileName,
                       sizeof(table_entry->cltConfigRemoteUpgradeFileName));
                memset(table_entry->old_cltConfigRemoteUpgradeFileName, 0,
                       sizeof(table_entry->cltConfigRemoteUpgradeFileName));
                table_entry->cltConfigRemoteUpgradeFileName_len =
                    table_entry->old_cltConfigRemoteUpgradeFileName_len;
                break;
            case COLUMN_REMOTEUPGRADEUSERNAME:
                memcpy(table_entry->remoteUpgradeUsername,
                       table_entry->old_remoteUpgradeUsername,
                       sizeof(table_entry->remoteUpgradeUsername));
                memset(table_entry->old_remoteUpgradeUsername, 0,
                       sizeof(table_entry->remoteUpgradeUsername));
                table_entry->remoteUpgradeUsername_len =
                    table_entry->old_remoteUpgradeUsername_len;
                break;
            case COLUMN_REMOTEUPGRADEPASSWORD:
                memcpy(table_entry->remoteUpgradePassword,
                       table_entry->old_remoteUpgradePassword,
                       sizeof(table_entry->remoteUpgradePassword));
                memset(table_entry->old_remoteUpgradePassword, 0,
                       sizeof(table_entry->remoteUpgradePassword));
                table_entry->remoteUpgradePassword_len =
                    table_entry->old_remoteUpgradePassword_len;
                break;
            case COLUMN_CLTCONFIGREMOTEUPGRADEINTERVAL:
                table_entry->cltConfigRemoteUpgradeInterval =
                    table_entry->old_cltConfigRemoteUpgradeInterval;
                table_entry->old_cltConfigRemoteUpgradeInterval = 0;
                break;
            case COLUMN_REMOTEUPGRADESUBMIT:
                table_entry->remoteUpgradeSubmit =
                    table_entry->old_remoteUpgradeSubmit;
                table_entry->old_remoteUpgradeSubmit = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
		for (table_entry = cltConfigRemoteUpgradeTable_head; table_entry; table_entry = table_entry->next)
		{	
			count++;
			DEBUGMSGTL((DBGTOKEN, "get table_entry:%d\n", count));
			if (table_entry->row_updates) 
			{
				DEBUGMSGTL((DBGTOKEN, "analogPropertyTable backup CommitEntry (%d)\n", table_entry->alarms_id));
                if(NULL == cltConfigRemoteUpgradeTable_backupCommitEntry(table_entry))
                {
					DEBUGMSGTL((DBGTOKEN, "error:backupCommitEntry fail\n"));			                	
                }
			}	
		}		
		RemoteUpgrade_local_commit(netsnmp_cache_reqinfo_extract(reqinfo, reginfo->handlerName));			
        break;
    }
    return SNMP_ERR_NOERROR;
}
/*begin add by zhouguanhua 2013/5/8 for bug id 41*/
void deleFile(char *appPath)
{
    if(unlink(appPath) <0)
    {   
        DEBUGMSGTL((DBGTOKEN, "error:dele file %s fail\n",appPath));
    }    
}
/*end add by zhouguanhua 2013/5/8 for bug id 41*/

/*****************************************************************
    Function:remoteUpgradeProcess
    Description:remoteUpgrade Process
    Author:huangmingjian
    Date:2013/02/01
    Input:   void
    Output:         
    Return:error type
   
=================================================
    Note:
*****************************************************************/ 

int remoteUpgradeProcess(void)
{
	sys_admin_t *info= NULL;
	ipc_sys_admin_ack_t *pack_admin = NULL;
	char username[MAX_ADMIN_NAME_SIZE] = {0};
	char password[MAX_ADMIN_PWD_SIZE] = {0};
	char auxusername[MAX_ADMIN_NAME_SIZE] = {0};
	char auxpassword[MAX_ADMIN_PWD_SIZE] = {0};
	unsigned long len = 0;
	int ret = REMOTEUPGRADE_OTHER_ERROR;
	char cmd_str[MAX_BUF_SIZE] = {0};
	char appPath[64] = {0};
	FILE* fp = NULL;
	UINT8 *pbuf = NULL;
	struct stat fs;
	ipc_system_ack_t *pack = NULL;	
	remoteUpgrade_t *pinfo = &g_remoteUpgradeInfo;
	
	if(ENABLE == pinfo->enable)
	{	
		pack_admin = ipc_sys_admin(ipc_fd, IPC_CONFIG_GET, IPC_APPLY_NONE, NULL);
		if(pack_admin && pack_admin->hdr.status == IPC_STATUS_OK) 
		{
			info = &pack_admin->admin;
			strncpy(username, info->users[0].name, sizeof(username));	
			strncpy(password, info->users[0].pwd, sizeof(password));
				
			DEBUGMSGTL((DBGTOKEN,"info->users[0].name=%s, pinfo->username=%s\n", info->users[0].name, pinfo->username));
			DEBUGMSGTL((DBGTOKEN,"info->users[0].pwd=%s, pinfo->password=%s\n", info->users[0].pwd, pinfo->password));
            strncpy(auxusername, info->users[1].name, sizeof(auxusername));   
            strncpy(auxpassword, info->users[1].pwd, sizeof(auxpassword));                
            DEBUGMSGTL((DBGTOKEN,"info->users[1].name=%s, pinfo->username=%s\n", info->users[1].name, pinfo->username));
            DEBUGMSGTL((DBGTOKEN,"info->users[1].pwd=%s, pinfo->password=%s\n", info->users[1].pwd, pinfo->password));
		}
		else
		{	
			if(pack_admin) 
			{
				free(pack_admin);	
			}
			DEBUGMSGTL((DBGTOKEN,"snmp get admin info error!\n"));
			return REMOTEUPGRADE_USERNAME_PASSWD_ERROR;
		}
		if(pack_admin) 
		{
			free(pack_admin);	
		}		
		
		if(((0 == strcmp(username, pinfo->username)) && (0 == strcmp(password, pinfo->password)))
		    || ((0 == strcmp(auxusername, pinfo->username)) && (0 == strcmp(auxpassword, pinfo->password))))
		{
			len = strlen(pinfo->filename);
			if((len < 4) || strncmp(&((pinfo->filename)[len-4]), ".bin", 4))
			{
				DEBUGMSGTL((DBGTOKEN,"File %s is not bin type\n", pinfo->filename));
				return REMOTEUPGRADE_NOTBINTYPE;
			}
			sprintf(cmd_str, "tftp -g -l %s%s -r %s %s", UFILE_TMP_PATH, pinfo->filename, pinfo->filename, inet_ntoa(current_pc_ip));
			DEBUGMSGTL((DBGTOKEN,"Download %s, waiting...\n", pinfo->filename));
			ret = system(cmd_str);
			if(-1 == ret || 127 == ret)
			{	
				DEBUGMSGTL((DBGTOKEN,"Cmd:%s error(%s),ret=%d\n", cmd_str, strerror(errno), ret));
				return REMOTEUPGRADE_DOWNLOAD_FILE_FAIL;
			}
			else
			{	
				DEBUGMSGTL((DBGTOKEN,"Download %s ok(%d)...\n", pinfo->filename, ret));
			}
 	
            sprintf(appPath, "%s%s", UFILE_TMP_PATH, pinfo->filename);

			if(stat(appPath, &fs) < 0)
			{
			   deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41
			   DEBUGMSGTL((DBGTOKEN,"Get file %s property error:%s!\n", appPath, strerror(errno)));
			   return REMOTEUPGRADE_FILE_NOT_EXIST;
			}
			len = fs.st_size;
			if(len > 0)
 			{	
	 			if(NULL == (fp = fopen(appPath, "r"))) 
				{
				   deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41
				   DEBUGMSGTL((DBGTOKEN,"Could not open file : %s(%s)\n", appPath, strerror(errno)));
				   return REMOTEUPGRADE_OPEN_FILE_FAIL;
				}
				pbuf = (UINT8 *)malloc(len); 
			    if(NULL == pbuf)
			    {
			       fclose(fp);
			       deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41
				   DEBUGMSGTL((DBGTOKEN,"Malloc pbuf fail\n"));
			       return REMOTEUPGRADE_OTHER_ERROR;
			    }  
			    if(-1 == fseek(fp, 0, SEEK_SET))
			    {
			       free(pbuf);
			       deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41
			       fclose(fp);
				   DEBUGMSGTL((DBGTOKEN,"fseek fail\n"));
			       return REMOTEUPGRADE_OTHER_ERROR;
			    } 
				memset(pbuf, '\0', len);
				if(fread(pbuf, sizeof(uint8_t), len, fp) !=  len)
				{
			      free(pbuf);
			      fclose(fp);
			      deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41
				  DEBUGMSGTL((DBGTOKEN,"read %ld size data to pbuf fail\n", len));
			      return REMOTEUPGRADE_OTHER_ERROR;
				} 
				deleFile(appPath);//add by zhouguanhua 2013/5/8/ for bug id 41 
				fclose(fp);
				DEBUGMSGTL((DBGTOKEN,"read %ld size data\n", len));
			}
            /*begin add by zhouguanhua 2013/5/8 for bug id 41*/			
			else
			{
			    deleFile(appPath); 
			    return REMOTEUPGRADE_OTHER_ERROR;
			}
			/*end  add by zhouguanhua 2013/5/8 for bug id 41*/
		    #if 1
			/*Begin add by huangmingjian 2014-04-24 for Bug 551*/
			ret = fw_head_check(pbuf, len);
			if(UP_OK != ret)
			{
				DEBUGMSGTL((DBGTOKEN,"ufile validate fail %d\n", ret));
		        free(pbuf);
			    fclose(fp);
			    deleFile(appPath);
				return REMOTEUPGRADE_FILE_CHECK_ERROR;
			}
			/*End add by huangmingjian 2014-04-24 for Bug 551*/
	    	#else
			if(UP_OK != (ret = ufile_validate(pbuf, len)))
			{	
				free(pbuf);
				DEBUGMSGTL((DBGTOKEN,"ufile validate fail %d\n", ret));
				return REMOTEUPGRADE_FILE_CHECK_ERROR;
			}
			#endif
            /*begin add by zhouguanhua 2013/5/8 for bug id 41*/                       
            if(UP_OK != (ret = ufile_process(pbuf, len)))
            {
				free(pbuf);
				DEBUGMSGTL((DBGTOKEN,"ufile process fail %d\n", ret));
				return REMOTEUPGRADE_FILE_CHECK_ERROR;            
            }
            /*end  add by zhouguanhua 2013/5/8 for bug id 41*/
			free(pbuf);

			#ifdef CONFIG_BOOT_MULTI_APP
			if(UP_OK != (ret=get_bootflag()))
			{
				DEBUGMSGTL((DBGTOKEN,"get bootflag fail:%d\n", ret));
				return REMOTEUPGRADE_OTHER_ERROR;
			}
			#else
			_ufile_content = UPGRADE_APP_0;
			#endif

			pack = ipc_system_req(ipc_fd, IPC_SYS_UPGRADE_APP, ufile_content());
			if(pack && (pack->hdr.status != IPC_STATUS_OK))
			{	
				if(pack) 
				{
					free(pack);
				}	
				return REMOTEUPGRADE_UPGRADE_APP_ERROR;
			}
			
			if(pack) 
			{
				free(pack);
			}	
			ret = REMOTEUPGRADE_OK;
		}
		else
		{
			return REMOTEUPGRADE_USERNAME_PASSWD_ERROR;
		}			
	}
	else
	{
		return REMOTEUPGRADE_DISABLE;
	}
	
	return ret;
}


/*****************************************************************
    Function:remoteUpgrade_send_trap_when_error
    Description:send trap when errors happen
    Author:huangmingjian
    Date:2013/02/01
    Input:   type: error type
    Output:         
    Return:
   
=================================================
    Note:
*****************************************************************/ 


void remoteUpgrade_send_trap_when_error(int type)
{
	char *remote_updagrade_error[] = {
		"",
		"Remote Updagrade:it has other error!",          						 /*-1*/
		"Remote Updagrade:the file is not \"bin\"type!",  						 /*-2*/
		"Remote Updagrade:download the file fail!", 	 						 /*-3*/
		"Remote Updagrade:open the file fail!", 		 						 /*-4*/
		"Remote Updagrade:the file check fail!", 		 						 /*-5*/
		"Remote Updagrade:upgrade app error!",			 						 /*-6*/
		"Remote Updagrade:the file is not exist!",	  	 						 /*-7*/
		"Remote Updagrade:remoteUpgradeSubmit and remoteUpgradeEnable value should be 1 at the same time when upgrade!",	 /*-8*/
		"Remote Updagrade:username or password error!"							 /*-9*/
		};	

	DEBUGMSGTL((DBGTOKEN,"error info is:%s(%d)\n",  remote_updagrade_error[-type], -type));
	send_RemoteUpgrade_Error_trap(remote_updagrade_error[-type]);
	return;
}

static int cltConfigRemoteUpgradeTable_commitChange(void)
{
	int error_type = 0;
	int count = 0;
	struct cltConfigRemoteUpgradeTable_entry *ptr = NULL;
	remoteUpgrade_t *sa = NULL;

	for (ptr = cltConfigRemoteUpgradeTable_commit_head; ptr != NULL; ptr = ptr->next) 
	{
		count++;
	}
	
	if (0 == count)
	{	
		DEBUGMSGTL((DBGTOKEN,"error: count is 0\n"));
		return -1;
	}
	
	DEBUGMSGTL((DBGTOKEN,"count=%d\n", count));

	sa = &g_remoteUpgradeInfo;
	count = 0;
	for ( ptr = cltConfigRemoteUpgradeTable_commit_head; ptr != NULL; ptr = ptr->next) {

		if (!cltConfigRemoteUpgradeTable_checkEntry(ptr)){
			DBG_ASSERT(0, "opRxInputTable values disorder");
		}
		
		sa->enable = ptr->remoteUpgradeEnable;
		
		sa->current_pc_ip = ptr->remoteUpgradeCurrentPcIP;

        memset(sa->filename,0,sizeof(sa->filename));
		strncpy(sa->filename, ptr->cltConfigRemoteUpgradeFileName, sizeof(sa->filename));/*modify by zhouguanhua 2013/9/2 for bug id 213*/
		sa->filename_len = ptr->cltConfigRemoteUpgradeFileName_len;
		
		memset(sa->username,0,sizeof(sa->username));
		strncpy(sa->username, ptr->remoteUpgradeUsername, sizeof(sa->username));
		sa->username_len = ptr->remoteUpgradeUsername_len;
		
		memset(sa->password,0,sizeof(sa->password));
		strncpy(sa->password, ptr->remoteUpgradePassword, sizeof(sa->password));
		sa->password_len = ptr->remoteUpgradePassword_len;

		sa->interval = ptr->cltConfigRemoteUpgradeInterval;
		
		sa->submit = ptr->remoteUpgradeSubmit;
		
		sa++;
		count ++;
	}

	current_pc_ip.s_addr = g_remoteUpgradeInfo.current_pc_ip;
    DEBUGMSGTL((DBGTOKEN,
                "remoteUpgrade set commit:\ng_remoteUpgradeInfo.enable=%d\n \
                 g_remoteUpgradeInfo.current_pc_ip=%s\n \
                 g_remoteUpgradeInfo.filename=%s\n \
                 g_remoteUpgradeInfo.username=%s\n \
                 g_remoteUpgradeInfo.password=%s\n \
                 g_remoteUpgradeInfo.interval=%ld\n \
                 g_remoteUpgradeInfo.submit=%d\n"
                 ,g_remoteUpgradeInfo.enable \
                 ,inet_ntoa(current_pc_ip)\
                 ,g_remoteUpgradeInfo.filename \
                 ,g_remoteUpgradeInfo.username \
                 ,g_remoteUpgradeInfo.password \
                 ,g_remoteUpgradeInfo.interval \
                 ,g_remoteUpgradeInfo.submit));

	if(SUBMIT_ENABLE == g_remoteUpgradeInfo.submit)
	{
		g_remoteUpgradeInfo.submit = SUBMIT_DISABLE;
		if((error_type = remoteUpgradeProcess()) < 0)
		{
			remoteUpgrade_send_trap_when_error(error_type);
		}
	}

	return 0;
}


void cltConfigRemoteUpgradeTable_commit(unsigned int regNo, void *clientargs)
{
	netsnmp_cache  *cache = clientargs;
	
	if(-1 == cltConfigRemoteUpgradeTable_commitChange())
	{
		DEBUGMSGTL((DBGTOKEN,"error: commitChange fail\n"));
		return;
	}
	cltConfigRemoteUpgradeTable_removeAllCommitEntry();
	COMMIT_CLEAR_PENDING(); 
	if (cache)
	{
		cache->valid = 0;
	}

	return;
}

