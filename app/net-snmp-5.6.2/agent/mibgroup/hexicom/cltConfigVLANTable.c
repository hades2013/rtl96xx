/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cltConfigVLANTable.h"

#include "hexicomTC.h"

#undef DBGID
#define DBGID  "hc:cltvlantable"

#ifndef DBGID
#define DBGID "defalut"
#endif 


LOCAL_COMMIT_DECLARE();

#define local_commit()  LOCAL_COMMIT(500, cltConfigVLANTable_commit, NULL)


vlan_portlist_t vlan_member2portlist(vlan_member_t member)
{
	vlan_portlist_t vplist = 0;
	if (member & ETH0_PORT_NUMBER){
		vplist |= VLANIF_ETH0;
	}
	if (member & ETH1_PORT_NUMBER){
		vplist |= VLANIF_ETH1;
	}
	if (member & CLT0_PORT_NUMBER){
		vplist |= VLANIF_CAB0;
	}
	if (member & CLT1_PORT_NUMBER){
		vplist |= VLANIF_CAB1;
	}
	return vplist;
}

vlan_member_t vlan_portlist2member(vlan_portlist_t *vplist)
{
	vlan_member_t member = 0;
	
	if (*vplist & VLANIF_ETH0){
		member |= ETH0_PORT_NUMBER;
	}

	if (*vplist & VLANIF_ETH1){
		member |= ETH1_PORT_NUMBER;
	}

	if (*vplist & VLANIF_CAB0){
		member |= CLT0_PORT_NUMBER;
	}

	if (*vplist & VLANIF_CAB1){
		member |= CLT1_PORT_NUMBER;
	}
	
	return member;
}


/*
  Actually, only trunk port or hybrid can be set in vlan table
  for access port , it was done by system logic
	for trunk port, it only can be set in portlist column , if pvid is in trunk allowed plist, it will automatically add to untagged list
	for hybrid port, it can be set in portlist column and untaggedlist column

*/
int valid_vlan_portlist(void* val)
{
	vlan_portlist_t *p = val;
	return (*p & ~VLANIF_ALL) ? 0 : 1;
}



/** Initializes the cltConfigVLANTable module */
void
init_cltConfigVLANTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_cltConfigVLANTable();
}

//# Determine the first/last column names

/** Initialize the cltConfigVLANTable table by defining its contents and how it's structured */
void
initialize_table_cltConfigVLANTable(void)
{
    static oid      cltConfigVLANTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 36368, 1, 1, 1, 1, 2, 3, 4 };
    size_t          cltConfigVLANTable_oid_len =
        OID_LENGTH(cltConfigVLANTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

	DEBUGMSGTL((DBGID, "Initializing\n"));

    reg =
        netsnmp_create_handler_registration("cltConfigVLANTable",
                                            cltConfigVLANTable_handler,
                                            cltConfigVLANTable_oid,
                                            cltConfigVLANTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: cltConfigVLANID */
                                     0);
    table_info->min_column = COLUMN_CLTCONFIGVLANINDEX;
    table_info->max_column = COLUMN_CLTCONFIGVLANROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = cltConfigVLANTable_get_first_data_point;
    iinfo->get_next_data_point = cltConfigVLANTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    netsnmp_inject_handler( reg,
		    netsnmp_get_cache_handler(HC_CACHE_TIMEOUT,
			   		cltConfigVLANTable_load, cltConfigVLANTable_free,
					cltConfigVLANTable_oid, OID_LENGTH(cltConfigVLANTable_oid)));
    DEBUGMSGTL((DBGID,
                "initialize cltConfigVLANTable\n"));     


    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */
struct cltConfigVLANTable_entry {
    /*
     * Index values 
     */
 //   long            cltConfigVLANID;

    /*
     * Column values 
     */
    long            cltConfigVLANIndex;
    long            cltConfigVLANID;
    long            old_cltConfigVLANID;
    char            cltConfigVLANPortList[HC_VLAN_PORT_SIZE];
    size_t          cltConfigVLANPortList_len;
    char            old_cltConfigVLANPortList[HC_VLAN_PORT_SIZE];
    size_t          old_cltConfigVLANPortList_len;
    char            cltConfigVLANUntaggedPortList[HC_VLAN_PORT_SIZE];
    size_t          cltConfigVLANUntaggedPortList_len;
    char            old_cltConfigVLANUntaggedPortList[HC_VLAN_PORT_SIZE];
    size_t          old_cltConfigVLANUntaggedPortList_len;
    long            cltConfigVLANRowStatus;
    long            old_cltConfigVLANRowStatus;

    /*
     * Illustrate using a simple linked list 
     */
    int             valid;
    struct cltConfigVLANTable_entry *next;
};

struct cltConfigVLANTable_entry *cltConfigVLANTable_head;
struct cltConfigVLANTable_entry *cltConfigVLANTable_commit_head;
struct cltConfigVLANTable_entry *cltConfigVLANTable_creating_head = NULL;


/*
 * create a new row in the (unsorted) table 
 */
struct cltConfigVLANTable_entry *
cltConfigVLANTable_createEntry(long cltConfigVLANIndex,
						long vlan_id,
						vlan_portlist_t *member, vlan_portlist_t *untagged_member)
{
    struct cltConfigVLANTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltConfigVLANTable_entry);
    if (!entry)
        return NULL;
	entry->cltConfigVLANID = vlan_id;
	memcpy(entry->cltConfigVLANPortList, member,sizeof(vlan_portlist_t));
	memcpy(entry->cltConfigVLANUntaggedPortList, untagged_member,sizeof(vlan_portlist_t));

	entry->cltConfigVLANPortList_len = sizeof(vlan_portlist_t);
	entry->cltConfigVLANUntaggedPortList_len = sizeof(vlan_portlist_t);	
	entry->cltConfigVLANRowStatus = RowStatus_active;

    entry->cltConfigVLANIndex = cltConfigVLANIndex;
    entry->next = cltConfigVLANTable_head;
    cltConfigVLANTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
cltConfigVLANTable_removeEntry(struct cltConfigVLANTable_entry *entry)
{
    struct cltConfigVLANTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = cltConfigVLANTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltConfigVLANTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

void cltConfigVLANTable_removeAllEntry(void )
{
    struct cltConfigVLANTable_entry *ptr, *pnext;

    for (ptr = cltConfigVLANTable_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigVLANTable_head = NULL;
}



struct cltConfigVLANTable_entry *
cltConfigVLANTable_backupCommitEntry(
				struct cltConfigVLANTable_entry *cltConfigVLANTable)
{
    struct cltConfigVLANTable_entry *entry, *next;

    for (entry = cltConfigVLANTable_commit_head; entry != NULL; entry = entry->next) {
		if (entry->cltConfigVLANIndex == cltConfigVLANTable->cltConfigVLANIndex){
			break;
		}		
    }	

	if (!entry){
		entry = SNMP_MALLOC_TYPEDEF(struct cltConfigVLANTable_entry);
		if (!entry)
			return NULL;
		entry->next = cltConfigVLANTable_commit_head;
		cltConfigVLANTable_commit_head = entry;
	}

	
	next = entry->next;
	memcpy(entry, cltConfigVLANTable, sizeof(*entry));
	entry->next = next;
	
    return entry;	
}


void cltConfigVLANTable_removeAllCommitEntry(void )
{
    struct cltConfigVLANTable_entry *ptr, *pnext;

    for (ptr = cltConfigVLANTable_commit_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigVLANTable_commit_head = NULL;
}


void cltConfigVLANTable_createCreatingEntry(long cltConfigVLANIndex )
{
    struct cltConfigVLANTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct cltConfigVLANTable_entry);
    if (!entry)
        return ;
	entry->cltConfigVLANID = 0;
	entry->cltConfigVLANPortList[0] = VLANIF_ALL;
	entry->cltConfigVLANPortList_len = sizeof(vlan_portlist_t);
	entry->cltConfigVLANUntaggedPortList[0] = 0;
	entry->cltConfigVLANUntaggedPortList_len = sizeof(vlan_portlist_t);

	entry->cltConfigVLANRowStatus = USERRowStatus_createAndWait;
    entry->cltConfigVLANIndex = cltConfigVLANIndex;
    entry->next = cltConfigVLANTable_creating_head;
    cltConfigVLANTable_creating_head = entry;
}



void cltConfigVLANTable_removeAllCreatingEntry(void )
{
    struct cltConfigVLANTable_entry *ptr, *pnext;

    for (ptr = cltConfigVLANTable_creating_head; ptr != NULL; ptr = pnext) {
		 pnext = ptr->next;
		 SNMP_FREE(ptr); 
    }
	cltConfigVLANTable_creating_head = NULL;
}



void cltConfigVLANTable_removeCreatingEntry(long cltConfigVLANIndex)
{
    struct cltConfigVLANTable_entry *ptr, *prev;

    for (ptr = cltConfigVLANTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr->cltConfigVLANIndex == cltConfigVLANIndex)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        cltConfigVLANTable_creating_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(ptr);   
}



/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
cltConfigVLANTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
    *my_loop_context = cltConfigVLANTable_head;
    return cltConfigVLANTable_get_next_data_point(my_loop_context,
                                                  my_data_context,
                                                  put_index_data, mydata);
}

netsnmp_variable_list *
cltConfigVLANTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    struct cltConfigVLANTable_entry *entry =
        (struct cltConfigVLANTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->cltConfigVLANIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the cltConfigVLANTable table */
int
cltConfigVLANTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
	int ret;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct cltConfigVLANTable_entry *table_entry;

	netsnmp_variable_list *requestvb;	

    if (((reqinfo->mode == MODE_GET) || (reqinfo->mode == MODE_SET_ACTION)) 
		&& !netsnmp_cache_is_valid(reqinfo, reginfo->handlerName)) {
        netsnmp_assert(!"cache == valid"); /* always false */
        cltConfigVLANTable_load( NULL, NULL );	/* XXX - check for failure */
    }

    DEBUGMSGTL((DBGID, "Handler - mode %s\n",
                    se_find_label_in_slist("agent_mode", reqinfo->mode)));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigVLANTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);		

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGVLANINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigVLANIndex);
                break;
            case COLUMN_CLTCONFIGVLANID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->cltConfigVLANID);
                break;
            case COLUMN_CLTCONFIGVLANPORTLIST:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltConfigVLANPortList,
                                         table_entry->
                                         cltConfigVLANPortList_len);
                break;
            case COLUMN_CLTCONFIGVLANUNTAGGEDPORTLIST:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         cltConfigVLANUntaggedPortList,
                                         table_entry->
                                         cltConfigVLANUntaggedPortList_len);
                break;
            case COLUMN_CLTCONFIGVLANROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           cltConfigVLANRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigVLANTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);		

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGVLANID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */	
                ret = netsnmp_check_vb_int_range(request->requestvb, 1, 4094);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				/*if this entry is active, vid can not be changed*/
				/*if vlan id exist , vid cab not be set*/
				if ((dot1q_vlans[vb_int(request->requestvb)].id.value > 0)
					|| (table_entry->cltConfigVLANRowStatus != RowStatus_createAndWait)){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}				
                break;
            case COLUMN_CLTCONFIGVLANPORTLIST:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              cltConfigVLANPortList));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!valid_vlan_portlist(request->requestvb->val.string)){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
				}

				
                break;
            case COLUMN_CLTCONFIGVLANUNTAGGEDPORTLIST:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              cltConfigVLANUntaggedPortList));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!valid_vlan_portlist(request->requestvb->val.string)){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
				}
				
                break;
            case COLUMN_CLTCONFIGVLANROWSTATUS:
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
				if (!validRowStatus(vb_int(request->requestvb))){
                    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;					
				}
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigVLANTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);


			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);		

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGVLANID:
                table_entry->old_cltConfigVLANID =
                    table_entry->cltConfigVLANID;
                table_entry->cltConfigVLANID =
                    *request->requestvb->val.integer;
                break;
            case COLUMN_CLTCONFIGVLANPORTLIST:
                memcpy(table_entry->old_cltConfigVLANPortList,
                       table_entry->cltConfigVLANPortList,
                       sizeof(table_entry->cltConfigVLANPortList));
                table_entry->old_cltConfigVLANPortList_len =
                    table_entry->cltConfigVLANPortList_len;
                memset(table_entry->cltConfigVLANPortList, 0,
                       sizeof(table_entry->cltConfigVLANPortList));
                memcpy(table_entry->cltConfigVLANPortList,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltConfigVLANPortList_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTCONFIGVLANUNTAGGEDPORTLIST:
                memcpy(table_entry->old_cltConfigVLANUntaggedPortList,
                       table_entry->cltConfigVLANUntaggedPortList,
                       sizeof(table_entry->cltConfigVLANUntaggedPortList));
                table_entry->old_cltConfigVLANUntaggedPortList_len =
                    table_entry->cltConfigVLANUntaggedPortList_len;
                memset(table_entry->cltConfigVLANUntaggedPortList, 0,
                       sizeof(table_entry->cltConfigVLANUntaggedPortList));
                memcpy(table_entry->cltConfigVLANUntaggedPortList,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->cltConfigVLANUntaggedPortList_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_CLTCONFIGVLANROWSTATUS:
                table_entry->old_cltConfigVLANRowStatus =
                    table_entry->cltConfigVLANRowStatus;
                table_entry->cltConfigVLANRowStatus =
                    *request->requestvb->val.integer;
				break;
            }
			cltConfigVLANTable_backupCommitEntry(table_entry);						
           // }
        }
        /*
         * Check the internal consistency of an active row 
      
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigVLANTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGVLANROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if ( 0 ) {
                        netsnmp_set_request_error(reqinfo, request,
                                                  SNMP_ERR_INCONSISTENTVALUE);
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
           }*/
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct cltConfigVLANTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			requestvb = request->requestvb;
			HC_DBG_OID(requestvb);		

            switch (table_info->colnum) {
            case COLUMN_CLTCONFIGVLANID:
                table_entry->cltConfigVLANID =
                    table_entry->old_cltConfigVLANID;
                table_entry->old_cltConfigVLANID = 0;
                break;
            case COLUMN_CLTCONFIGVLANPORTLIST:
                memcpy(table_entry->cltConfigVLANPortList,
                       table_entry->old_cltConfigVLANPortList,
                       sizeof(table_entry->cltConfigVLANPortList));
                memset(table_entry->old_cltConfigVLANPortList, 0,
                       sizeof(table_entry->cltConfigVLANPortList));
                table_entry->cltConfigVLANPortList_len =
                    table_entry->old_cltConfigVLANPortList_len;
                break;
            case COLUMN_CLTCONFIGVLANUNTAGGEDPORTLIST:
                memcpy(table_entry->cltConfigVLANUntaggedPortList,
                       table_entry->old_cltConfigVLANUntaggedPortList,
                       sizeof(table_entry->cltConfigVLANUntaggedPortList));
                memset(table_entry->old_cltConfigVLANUntaggedPortList, 0,
                       sizeof(table_entry->cltConfigVLANUntaggedPortList));
                table_entry->cltConfigVLANUntaggedPortList_len =
                    table_entry->old_cltConfigVLANUntaggedPortList_len;
                break;
            case COLUMN_CLTCONFIGVLANROWSTATUS:
                table_entry->cltConfigVLANRowStatus =
                    table_entry->old_cltConfigVLANRowStatus;
                table_entry->old_cltConfigVLANRowStatus = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
		local_commit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int cltConfigVLANTable_load(netsnmp_cache *cache, void *vmagic)
{
	struct cltConfigVLANTable_entry *ptr;
	vlan_portlist_t member, untagged;

	int ret, i, v;

	COMMIT_PENDING_ASSERT();

	/* Free All */
	DEBUGMSGTL((DBGID, "Free cltConfigVLANTable Group\n"));  
	cltConfigVLANTable_removeAllEntry();

	/* Load All */
		
	ret = vlan_update();
	
    if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to load vlan_update\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded vlan_update\n"));
    }

	HC_IPC_ASSERT(ret);

	if (sys_vlan_mode.mode == VLAN_MODE_TRANSPARENT){
		return 0;
	}


	// 802.1Q	
	ret = vlan_interface_update();
	
    if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to load vlan_interface_update\n"));
    } else {
		SET_VALID();
        DEBUGMSGTL((DBGID, "Loaded vlan_interface_update\n"));
    }

	HC_IPC_ASSERT(ret);


	/*
		VLAN untagged portlist, we need to parse from vlan interfaces
		for Access port, is untagged at vlanid = pvid
		for Trunk port, if pvid in allowed list, then untagged at vlanid = pvid
		for hybrid port untagged list is untagged
	*/
	dot1q_vlan_untagged_portlist_update();

	for (i = 0, v = 0; i < EOC_MAX_VLAN_NUMS; i ++){
		if (dot1q_vlans[i].id.value > 0){
			member = vlan_member2portlist(dot1q_vlans[i].member);
			untagged = vlan_member2portlist(dot1q_vlans_u[i].member);
			cltConfigVLANTable_createEntry(v + 1, dot1q_vlans[i].id.value, 
				&member, &untagged);
			v  ++;
		}
	}

	for (ptr = cltConfigVLANTable_creating_head; ptr != NULL; ptr = ptr->next, v ++)
	{
		ptr->cltConfigVLANIndex = v + 1;
		cltConfigVLANTable_createEntry(v + 1, 
			ptr->cltConfigVLANID, 
			(vlan_portlist_t*)ptr->cltConfigVLANPortList,
			(vlan_portlist_t*)ptr->cltConfigVLANUntaggedPortList);		
	}	

    return ret; 
} 

void cltConfigVLANTable_free(netsnmp_cache *cache, void *magic)
{

}


void cltConfigVLANTable_commit(unsigned int regNo, void *clientargs)
{
	long ret;
	struct cltConfigVLANTable_entry *ptr;
	switch_vlan_t vlans[EOC_MAX_VLAN_NUMS];
	int do_num = 0, vid, new_vlan = 0;
	vlan_member_t member, untagged;
	switch_vlan_group_t *vg;
	
	HC_VALID_ASSERT();


// Delete if any
// vlan 1 could not be deleted
// when ptr->rowstatus != create and wait, vlanid could not be set

	memset(vlans, 0, sizeof(vlans));

	for (ptr = cltConfigVLANTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if (ptr->cltConfigVLANRowStatus == RowStatus_destroy){
			if (ptr->old_cltConfigVLANRowStatus == RowStatus_createAndWait){
				//cltConfigVLANTable_removeAllCreatingEntry();

				cltConfigVLANTable_removeCreatingEntry(ptr->cltConfigVLANIndex);
			}else {
				vlans[ptr->cltConfigVLANID].id.value = ptr->cltConfigVLANID;
				do_num ++;
			}
		}
	}

	if (do_num){
		vg = vlan_group_new_from_hash(vlans, EOC_MAX_VLAN_NUMS);
		if (vg){
			ret = ipc_del_vlan(vg);
			if (HC_IPC_ERROR(ret)) {
				DEBUGMSGTL((DBGID, "Failed to delete cltConfigVLANTable Group\n"));
			} else {
				DEBUGMSGTL((DBGID, "Deleted cltConfigVLANTable Group\n"));
			}
			COMMIT_CLEAR_PENDING(); 	
			HC_IPC_ASSERT1(ret);
			return;
		}		
		COMMIT_CLEAR_PENDING(); 		
		HC_NOMEM_ASSERT1(vg);
		return ;
	}

// creat  if any
	for (ptr = cltConfigVLANTable_commit_head; ptr != NULL; ptr = ptr->next) {
		if ((ptr->cltConfigVLANRowStatus == RowStatus_createAndWait)
			&& (ptr->old_cltConfigVLANRowStatus != RowStatus_createAndWait) 
			&& (cltConfigVLANTable_creating_head == NULL)){
			cltConfigVLANTable_createCreatingEntry(0);

			COMMIT_CLEAR_PENDING();			
			return ;
		}
	}
	
	// apply all changes
#if 0
	ret = device_userlists_update();
	if (HC_IPC_ERROR(ret)) {
		CLR_VALID();
		DEBUGMSGTL((DBGID, "Failed to update cltConfigVLANTable Group\n"));
	} else {
		SET_VALID();
		DEBUGMSGTL((DBGID, "Updated cltConfigVLANTable Group\n"));
	}
	
	HC_IPC_ASSERT1(ret);	
#endif	

	do_num = 0;

	for (ptr = cltConfigVLANTable_commit_head; ptr != NULL; ptr = ptr->next) {
		/**/
		if ((ptr->old_cltConfigVLANRowStatus == RowStatus_createAndWait) 
			&& (ptr->cltConfigVLANRowStatus == RowStatus_active)){
			new_vlan = ptr->cltConfigVLANID;
		}		
		vid = ptr->cltConfigVLANID;
		member = vlan_portlist2member((vlan_portlist_t*)ptr->cltConfigVLANPortList);
		untagged = vlan_portlist2member((vlan_portlist_t*)ptr->cltConfigVLANUntaggedPortList);
		if ((dot1q_vlans[vid].id.value != vid)
			|| (dot1q_vlans[vid].member != member)
			|| (dot1q_vlans_u[vid].member != untagged)){
			do_num ++;
			dot1q_vlans[vid].id.value = vid;
			dot1q_vlans[vid].member = member;
			dot1q_vlans_u[vid].id.value = vid;
			dot1q_vlans_u[vid].member = untagged;
		}
		/*

		
		if ((ptr->old_cltNetworkUnitUserListRowStatus == RowStatus_createAndWait) 
			&& (ptr->cltNetworkUnitUserListRowStatus == RowStatus_active)){
			ret = cltConfigVLANTable_change_and_update(ptr, vlans, vlans_u);
			if (ret && valid_vlan_entry(ptr->cltConfigVLANID, vlans[ptr->cltConfigVLANID].member, vlans_u[ptr->cltConfigVLANID].member)){
				cltConfigVLANTable_removeCreatingEntry(ptr->cltConfigVLANIndex);				
				vids[do_num] == vid;
				do_num ++;
			}
		}else {
			vid = cltConfigVLANTable_change_and_update(ptr);
			if (vid){
				vids[do_num].vid  == vid;
				vids[do_num].member = member;
				vids[do_num].untagged = untagged;
				do_num ++;
			}
		}*/
	}

	cltConfigVLANTable_removeAllCommitEntry();

	if (do_num){
		ret = 0;
		if (new_vlan){
			ret = dot1q_vlan_commit();
			if (HC_IPC_ERROR(ret)) {
				
				DEBUGMSGTL((DBGID, "Failed to commit cltConfigVLANTable Group\n"));
			} else {
				DEBUGMSGTL((DBGID, "Commited cltConfigVLANTable Group\n"));
			}		
		}

		if (!HC_IPC_ERROR(ret)){
			ret = dot1q_vlan_interface_commit();
			if (HC_IPC_ERROR(ret)) {
				
				DEBUGMSGTL((DBGID, "Failed to commit cltConfigVLANTable Group\n"));
			} else {
				DEBUGMSGTL((DBGID, "Commited cltConfigVLANTable Group\n"));
			}
		}

		COMMIT_CLEAR_PENDING();
		HC_IPC_ASSERT1(ret);
	} 

	COMMIT_CLEAR_PENDING();
	
}


