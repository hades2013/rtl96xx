#!/usr/bin/env python
import re, sys

nodes = []
KEY_ITEM = 'Name'
MGMTNAME = ''

FUNC_TITLE = '/* This file is automatic generated by TCL scripts. */\n' +   \
        '/* Please do NOT modify this file directly. */\n\n' +              \
        '#include "app_basic.h"\n' +                                        \
        '#include "omci_defs.h"'

HEADER_TITLE = '/* This file is automatic generated by scripts. */\n' +     \
        '/* Please do NOT modify this file directly. */\n\n' +              \
        '#ifndef __MIB_%s_TABLE_H__\n' +                                    \
        '#define __MIB_%s_TABLE_H__\n\n'

VALID_TYPE = {  '0' : 'FALSE',
                '1' : 'TRUE',
             }

INIT_TYPE = {   'OLT' : 'PON_ME_INIT_TYPE_BY_OLT',
                'AUTO': 'PON_ME_INIT_TYPE_AUTO',
            }

USRACC_TYPE = { 'W' : 'MIB_ATTR_USR_WRITE',
                'R' : 'MIB_ATTR_USR_READ_ONLY',
              }

OLTACC_TYPE = { 'W' : 'PON_ME_OLT_READ | PON_ME_OLT_WRITE',
                'R' : 'PON_ME_OLT_READ',
              }

OPTION_TYPE = { 'N' : 'PON_ME_ATTR_OPT_NOT_SUPPORT',
                'S' : 'PON_ME_ATTR_OPT_SUPPORT',
                'M' : 'PON_ME_ATTR_MANDATORY',
                'P' : 'PON_ME_ATTR_PRIVATE',
              }

OUTSTYLE_TYPE = { 'CHAR' : '%s',
		  'HEX' : '0x%02x',
		  'DEC' : '%d',
		}

## A class of parse tree node
class attrNode:
    TOKENS = [ KEY_ITEM, 'Desc', 'Type', 'Len', 'IsIndex', 'UsrAcc', 'MibSave',
            'OutStyle', 'OltAcc', 'AvcFlag', 'OptionType', 'DefaultValue' ]
    TYPES = { 'UIN32'      : 'UINT32',
              'UIN16'      : 'UINT16',
            }
    ## Constructor.
    def __init__(self, name):
        self.Name = name.strip()
        return

def attr_parser(num, key, val):
    node = nodes[num]

    if not key in attrNode.TOKENS:
        print 'attr invalid input %d %s %s' % (num, key, val)
        sys.exit(-1)

    setattr(node, key.strip(), val.strip())

    return

class mgmtNode:
    TOKENS = [ KEY_ITEM, 'Desc', 'MaxEntry', 'ClassId', 'InitType', 'StdType', 'ActionType' ]
    ACTION_TYPES = {"Create"    : "PON_ME_ACTION_CREATE",
                    "Delete"    : "PON_ME_ACTION_DELETE",
                    "Set"       : "PON_ME_ACTION_SET",
                    "Get"       : "PON_ME_ACTION_GET",
		    "None"      : "PON_ME_ACTION_NONE",
		    "GetAllAlarm" : "PON_ME_ACTION_ALLALARM",
		    "GetAllAlarmNext" : "PON_ME_ACTION_ALLALARM_NEXT",
		    "MibUpload" : "PON_ME_ACTION_MIB_UPLOAD",
		    "MibUploadNext" : "PON_ME_ACTION_MIB_UPLOAD_NEXT",
	    	    "MibReset" : "PON_ME_ACTION_MIB_RESET",
		    "Test" : "PON_ME_ACTION_TEST",
		    "SwDownload" : "PON_ME_ACTION_SW_DOWNLOAD",
		    "SwDownloadSec" : "PON_ME_ACTION_SW_DOWNLOAD_SEC",
		    "SwDownloadEnd" : "PON_ME_ACTION_SW_DOWNLOAD_END",
		    "ActSw" : "PON_ME_ACTION_ACT_SW",
		    "CommitSw" : "PON_ME_ACTION_COMMIT_SW",
		    "SyncTime" : "PON_ME_ACTION_SYNC_TIME",
		    "Reboot" : "PON_ME_ACTION_REBOOT",
		    "GetNext" : "PON_ME_ACTION_GET_NEXT",
		    "GetCurData" : "PON_ME_ACTION_GET_CUR_DATA",
                   }
    ## Constructor.
    def __init__(self, name):
        self.Name = name.strip()
        return

def mgmt_parser(key, val):
    node = nodes[0]

    if not key in mgmtNode.TOKENS:
        print 'mgmt invalid input %s %s' % (key, val)
        sys.exit(-1)

    setattr(node, key.strip(), val.strip())

    return

def process_input_file(filedir, filename):
    global MGMTNAME
    line = ''
    lineNum = 0
    nodeNum = 0

    inFile = filedir + '/' + filename

    try:
        fin = open(inFile, 'r')
    except:
        print 'Fail to open %s.' % inFile
        sys.exit(-1)

    for line in fin:
        lineNum = lineNum + 1
        #print "%d) %s" % (lineNum, line)

        line = line.strip()

        if len(line) == 0:
            continue

        ## skip #
        comment = re.search('^\#', line)
        if comment:
            continue

        #parameter = line.strip.split(":")
        key, val = map(str, line.split(":"))

        if key == KEY_ITEM:
            if nodeNum == 0:
                MGMTNAME = val.strip()
            nodeNum = nodeNum + 1
            nodes.append(mgmtNode(val))
        else:
            if nodeNum == 1:
                mgmt_parser(key, val)
            else:
                attr_parser(nodeNum - 1, key, val)
    fin.close()

    return

def actionParser(actionType):
    actionStr = ''
    actType = actionType.split(",")

    for idx in xrange(len(actType)):
        if idx >= 1:
            actionStr = actionStr + ' | '
        actionStr = actionStr + '%s' % mgmtNode.ACTION_TYPES[actType[idx]]
    return actionStr

def func_output(filedir):
    global MGMTNAME

    outf = filedir + "/mib_%s.c" % MGMTNAME

    try:
        fout = open(outf, 'w+')
    except:
        print 'Fail to open %s.' % outf
        sys.exit(-1)

    fout.write(FUNC_TITLE)
    fout.write('\n\n')
    #global
    fout.write('MIB_TABLE_INFO_T gMib%sTableInfo;\n' % MGMTNAME)
    fout.write('MIB_ATTR_INFO_T  gMib%sAttrInfo[MIB_TABLE_%s_ATTR_NUM];\n' % (MGMTNAME, MGMTNAME.upper()))
    fout.write('MIB_TABLE_%s_T gMib%sDefRow;\n' % (MGMTNAME.upper(), MGMTNAME))
    fout.write('MIB_TABLE_OPER_T gMib%sOper;\n' % MGMTNAME)
    fout.write('\n\n')
    #
    fout.write('GOS_ERROR_CODE %s_DumpMe(void *pData)\n' % MGMTNAME)
    fout.write('{\n')
    fout.write('	MIB_TABLE_%s_T *p%s = (MIB_TABLE_%s_T*)pData;\n'% (MGMTNAME.upper(), MGMTNAME, MGMTNAME.upper()))
    fout.write('	OMCI_LOG(OMCI_LOG_LEVEL_HIGH,"%%s", "%s");\n' % MGMTNAME)
    fout.write('\n')
    for i in xrange(1, len(nodes)):
        fout.write('	OMCI_LOG(OMCI_LOG_LEVEL_HIGH,"%s: %s", p%s->%s);\n' % (nodes[i].Name,OUTSTYLE_TYPE[nodes[i].OutStyle],MGMTNAME, nodes[i].Name))
    fout.write('\n')
    fout.write('	return GOS_OK;\n')
    fout.write('}\n\n')
    #
    fout.write('GOS_ERROR_CODE %s_CfgMe(MIB_TABLE_INDEX tableIdx, void* pOldRow, void* pNewRow, MIB_OPERA_TYPE operationType)\n' % MGMTNAME)
    fout.write('{\n')
    fout.write('	OMCI_LOG(OMCI_LOG_LEVEL_LOW,"%s: process end\\n", __FUNCTION__);\n')
    fout.write('	return GOS_OK;\n')
    fout.write('}\n\n')
    #init
    fout.write('GOS_ERROR_CODE %s_Init(void)\n' % MGMTNAME)
    fout.write('{\n')
    fout.write('    gMib%sTableInfo.Name = "%s";\n' % (MGMTNAME, nodes[0].Name))
    fout.write('    gMib%sTableInfo.Desc = "%s";\n' % (MGMTNAME, nodes[0].Desc))
    fout.write('    gMib%sTableInfo.MaxEntry = (UINT32)(%s);\n' % (MGMTNAME, nodes[0].MaxEntry))
    fout.write('    gMib%sTableInfo.ClassId = (UINT32)(%s);\n' % (MGMTNAME, nodes[0].ClassId))
    fout.write('    gMib%sTableInfo.InitType = (UINT32)(%s);\n' % (MGMTNAME, INIT_TYPE[nodes[0].InitType.upper()]))
    fout.write('    gMib%sTableInfo.StdType = (UINT32)(PON_ME_STD_TYPE_%s);\n' % (MGMTNAME, nodes[0].StdType.upper()))
    fout.write('    gMib%sTableInfo.ActionType = (UINT32)(%s);\n' % (MGMTNAME, actionParser(nodes[0].ActionType)))
    fout.write('    gMib%sTableInfo.pAttributes = &(gMib%sAttrInfo[0]);\n' % (MGMTNAME, MGMTNAME))
    fout.write('\n')
    fout.write('	gMib%sTableInfo.attrNum = MIB_TABLE_%s_ATTR_NUM;\n' % (MGMTNAME, MGMTNAME.upper()))
    fout.write('	gMib%sTableInfo.entrySize = sizeof(MIB_TABLE_%s_T);\n' % (MGMTNAME, MGMTNAME.upper()))
    fout.write('	gMib%sTableInfo.pDefaultRow = &gMib%sDefRow;\n' % (MGMTNAME, MGMTNAME))
    fout.write('\n')

    #Name
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].Name = "%s";\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), nodes[i].Name))
    fout.write('\n')

    #Desc
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].Desc = "%s";\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), nodes[i].Desc))
    fout.write('\n')

    #DataType
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].DataType = MIB_ATTR_TYPE_%s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), nodes[i].Type))
    fout.write('\n')

    #Len
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].Len = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), nodes[i].Len))
    fout.write('\n')

    #IsIndex
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].IsIndex = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), VALID_TYPE[nodes[i].IsIndex]))
    fout.write('\n')

    #UsrAcc
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].UsrAcc = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), USRACC_TYPE[nodes[i].UsrAcc]))
    fout.write('\n')

    #MibSave
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].MibSave = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), VALID_TYPE[nodes[i].MibSave]))
    fout.write('\n')

    #OutStyle
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].OutStyle = MIB_ATTR_OUT_%s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), nodes[i].OutStyle.upper()))
    fout.write('\n')

    #OltAcc
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].OltAcc = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), OLTACC_TYPE[nodes[i].OltAcc]))
    fout.write('\n')

    #AvcFlag
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].AvcFlag = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), VALID_TYPE[nodes[i].AvcFlag]))
    fout.write('\n')

    #OptionType
    for i in xrange(1, len(nodes)):
        fout.write('    gMib%sAttrInfo[MIB_TABLE_%s_%s_INDEX - MIB_TABLE_FIRST_INDEX].OptionType = %s;\n'
                % (MGMTNAME, MGMTNAME.upper(), nodes[i].Name.upper(), OPTION_TYPE[nodes[i].OptionType]))
    fout.write('\n')

    #default value
    for i in xrange(1, len(nodes)):
        if nodes[i].Type == 'STR':
            fout.write('    strncpy(&(gMib%sDefRow.%s), "%s", sizeof(gMib%sDefRow.%s));\n'
                    % (MGMTNAME, nodes[i].Name, nodes[i].DefaultValue, MGMTNAME, nodes[i].Name))
        else:
            fout.write('    memset(&(gMib%sDefRow.%s), 0x%02d, sizeof(gMib%sDefRow.%s));\n'
                    % (MGMTNAME, nodes[i].Name, (int)(nodes[i].DefaultValue), MGMTNAME, nodes[i].Name))
    fout.write('\n')

    fout.write('    gMib%sOper.meCfg = %s_CfgMe;\n' % (MGMTNAME, MGMTNAME))
    fout.write('    gMib%sOper.meConnCheck = NULL;\n' % (MGMTNAME))
    fout.write('    gMib%sOper.meDump = %s_DumpMe;\n' % (MGMTNAME, MGMTNAME))
    fout.write('\n')

    fout.write('    MIB_Register(MIB_TABLE_%s_INDEX, &gMib%sTableInfo, &gMib%sOper);\n' % (MGMTNAME.upper(), MGMTNAME, MGMTNAME))
    fout.write('\n')
    fout.write('    return GOS_OK;\n')
    fout.write('}\n\n')

    fout.close()
    return

def include_output(filedir):
    global MGMTNAME
    outf = filedir + "/mib_tree.h"
    try:
  	fout = open(outf, 'aw+')
    except:
	print 'Fail to open %s.' % outf
	sys.exit(-1)

    fout.write('#include "mib_%s.h"\n' % MGMTNAME )
    fout.close()
    return 

def init_output(filedir):
    global MGMTNAME
    outf = filedir + "/mib_auto.c"
    try:
  	fout = open(outf, 'aw+')
    except:
	print 'Fail to open %s.' % outf
	sys.exit(-1)

    fout.write('%s_Init();\n' % MGMTNAME )
    fout.close()
    return 

def header_output(filedir):
    global MGMTNAME

    outf = filedir + "/mib_%s.h" % MGMTNAME

    try:
        fout = open(outf, 'w+')
    except:
        print 'Fail to open %s.' % outf
        sys.exit(-1)

    fout.write(HEADER_TITLE % (MGMTNAME.upper(), MGMTNAME.upper()))

    #attribute len
    fout.write('/* Table SWImage attribute len, only string attrubutes have length definition */\n');
    for idx in xrange(1, len(nodes)):
        if nodes[idx].Type == 'STR':
            fout.write('#define MIB_TABLE_%s_LEN (%s)\n' % (nodes[idx].Name.upper(), nodes[idx].Len))

    fout.write('\n')

    #attribute index
    fout.write('/* Table %s attribute index */\n' % MGMTNAME)
    fout.write('#define MIB_TABLE_%s_ATTR_NUM (%d)\n' % (MGMTNAME.upper(), len(nodes) - 1))

    for idx in xrange(1, len(nodes)):
        fout.write('#define MIB_TABLE_%s_%s_INDEX ((MIB_ATTR_INDEX)%d)\n' % (MGMTNAME.upper(), nodes[idx].Name.upper(), idx))

    fout.write('\n')

    #attribute structure
    fout.write('/* Table %s attribute len, only string attrubutes have length definition */\n' % MGMTNAME)
    fout.write('typedef struct {\n')

    offset = 0
    for idx in xrange(1, len(nodes)):
        attrLen = (int)(nodes[idx].Len)
        if nodes[idx].Type == 'STR':
            fout.write('\t%-8s %s[MIB_TABLE_%s_LEN+1];\n' % ('CHAR', nodes[idx].Name, nodes[idx].Name.upper()))
            offset += 1
        else:
            if offset % 4 != 0 and (offset / 4) != ((offset + attrLen) / 4):
                rsv = (4 - (offset % 4))
                fout.write('\t%-8s resv0[%d];\n' % ('UINT8', rsv))
                offset += rsv

            fout.write('\t%-8s %s;\n' % (nodes[idx].Type, nodes[idx].Name))

        offset += attrLen

    fout.write('} MIB_TABLE_%s_T;\n' % MGMTNAME.upper())
    fout.write('\n')

    fout.write('#endif /* __MIB_%s_TABLE_H__ */\n' % MGMTNAME.upper())

    fout.close()

    return

## Process the command-line argument
def main():
    f_dir   = '.'
    f_fname = ''
    # Parse input arguments
    sys.argv.pop(0) # remove mk_parser.py itself

    if len(sys.argv) == 0:
        sys.stdout.write("argv is null")
        return

    while (len(sys.argv) > 0):
        item = sys.argv.pop(0)
        if '-fd' == item:
            f_dir = sys.argv.pop(0)
        elif '-f' == item:
            f_fname = sys.argv.pop(0)
        else:
            sys.stdout.write("parameter incorrect\n")
            return

    process_input_file(f_dir, f_fname)

    func_output(f_dir)
    header_output(f_dir)
    include_output(f_dir)
    init_output(f_dir)
    return

# Entry point of the script
if __name__ == '__main__':
    main()

